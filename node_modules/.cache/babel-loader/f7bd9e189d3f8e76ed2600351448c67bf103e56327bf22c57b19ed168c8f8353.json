{"ast":null,"code":"var _jsxFileName = \"/Users/peterpressman/MyDevelopment/JavaScript/SynTactic-online/syntactile-words/src/components/GrammarGame.js\",\n  _s = $RefreshSig$();\n// src/GrammarGame.js\nimport React, { useState, useEffect } from 'react';\nimport Papa from 'papaparse';\nimport WordTile from './WordTile';\nimport SentenceSlot from './SentenceSlot';\nimport '.GrammarGame.css';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODES = {\n  PASSIVE: 'Passive Voice',\n  IMPERFECT: 'Imperfect Tense',\n  OBJECT_CLEFT: 'Object Cleft',\n  WH_QUESTION: 'Wh Questions'\n};\nconst MAX_TRIES = 3;\nconst POINTS_PER_QUESTION = 10;\nconst PENALTY_PER_TRY = 3;\nfunction GrammarGame() {\n  _s();\n  // Game state\n  const [mode, setMode] = useState(null);\n  const [sentences, setSentences] = useState([]);\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [currentImage, setCurrentImage] = useState(null);\n  const [isVersion2, setIsVersion2] = useState(false);\n  const [score, setScore] = useState(0);\n  const [triesLeft, setTriesLeft] = useState(MAX_TRIES);\n  const [feedback, setFeedback] = useState('');\n  const [isError, setIsError] = useState(false);\n  const [isComplete, setIsComplete] = useState(false);\n  const [results, setResults] = useState([]);\n\n  // Tiles and slots state\n  const [wordTiles, setWordTiles] = useState([]);\n  const [sentenceSlots, setSentenceSlots] = useState([]);\n  const [selectedTile, setSelectedTile] = useState(null);\n\n  // Load sentences from CSV\n  useEffect(() => {\n    loadSentences();\n  }, []);\n  const loadSentences = async () => {\n    try {\n      const response = await fetch('/sentences_corrected.csv');\n      const csvText = await response.text();\n      Papa.parse(csvText, {\n        header: true,\n        skipEmptyLines: true,\n        complete: results => {\n          setSentences(results.data);\n        }\n      });\n    } catch (error) {\n      console.error('Error loading CSV:', error);\n    }\n  };\n\n  // Get the correct order of tiles based on mode and version\n  const getCorrectOrder = (gameMode, version2) => {\n    switch (gameMode) {\n      case MODES.IMPERFECT:\n        return version2 ? ['A2', 'A5', 'A3', 'A1'] :\n        // Version 2\n        ['A1', 'A5', 'A3', 'A2'];\n      // Version 1\n      case MODES.PASSIVE:\n        return version2 ? ['A1', 'A5', 'A4', 'A6', 'A2', 'A3'] :\n        // Version 2\n        ['A2', 'A5', 'A4', 'A6', 'A1', 'A3'];\n      // Version 1\n      case MODES.OBJECT_CLEFT:\n        return version2 ? ['A4', 'A2', 'A5', 'A3', 'A1'] :\n        // Version 2\n        ['A4', 'A1', 'A5', 'A3', 'A2'];\n      // Version 1\n      case MODES.WH_QUESTION:\n        return version2 ? ['A5', 'A4', 'A2', 'A3', 'A1', 'A6'] :\n        // Version 2\n        ['A5', 'A4', 'A1', 'A3', 'A2', 'A6'];\n      // Version 1\n      default:\n        return [];\n    }\n  };\n\n  // Setup a new trial when mode or currentTrial changes\n  useEffect(() => {\n    if (mode && sentences.length > 0) {\n      setupNewTrial();\n    }\n  }, [mode, currentTrial, sentences]);\n  const setupNewTrial = () => {\n    if (!sentences[currentTrial]) return;\n    const sentence = sentences[currentTrial];\n    const version2 = sentence.Picture.includes(\"2\");\n    setIsVersion2(version2);\n    const pictureId = sentence.Picture.trim();\n    const imagePath = `/images/Pic${pictureId}.jpg`;\n    setCurrentImage(imagePath);\n    const tileOrder = getCorrectOrder(mode, version2);\n\n    // Define mode-to-folder mapping\n    const modeFolderMap = {\n      \"Passive Voice\": \"passive\",\n      \"Imperfect Tense\": \"imperfect\",\n      \"Object Cleft\": \"object_cleft\",\n      \"Wh Questions\": \"wh_questions\"\n    };\n\n    // Ensure mode maps to the correct folder name\n    const modeFolder = modeFolderMap[mode] || mode.toLowerCase();\n\n    // Create shuffled tiles\n    const shuffledTiles = shuffleArray(tileOrder.map((tileId, index) => ({\n      id: `tile-${index}`,\n      tileId: tileId,\n      imagePath: `/tiles/${modeFolder}/${tileId}.png`,\n      isUsed: false\n    })));\n    setWordTiles(shuffledTiles);\n\n    // Create empty sentence slots\n    const newSlots = tileOrder.map((_, index) => ({\n      id: `slot-${index}`,\n      position: index,\n      tileId: null,\n      wordTile: null\n    }));\n    setSentenceSlots(newSlots);\n    setTriesLeft(MAX_TRIES);\n    setFeedback('');\n    setIsError(false);\n    setSelectedTile(null);\n  };\n\n  // Handle tile selection\n  const handleTileClick = tileId => {\n    const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n    if (tileIndex !== -1 && !wordTiles[tileIndex].isUsed) {\n      setSelectedTile(tileId);\n    }\n  };\n\n  // Handle slot click - place a selected tile in a slot\n  const handleSlotClick = slotId => {\n    if (!selectedTile) return;\n    const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n\n    // Only allow placement in empty slots\n    if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId === null) {\n      // Find the tile\n      const tileIndex = wordTiles.findIndex(t => t.id === selectedTile);\n\n      // Update slots with the placed tile\n      const newSlots = [...sentenceSlots];\n      newSlots[slotIndex] = {\n        ...newSlots[slotIndex],\n        tileId: selectedTile,\n        wordTile: wordTiles[tileIndex]\n      };\n      setSentenceSlots(newSlots);\n\n      // Mark the tile as used\n      const newTiles = [...wordTiles];\n      newTiles[tileIndex] = {\n        ...newTiles[tileIndex],\n        isUsed: true\n      };\n      setWordTiles(newTiles);\n\n      // Clear selection\n      setSelectedTile(null);\n\n      // Check if sentence is complete\n      if (newSlots.every(slot => slot.wordTile !== null)) {\n        checkSentence(newSlots);\n      }\n    }\n  };\n\n  // Remove a tile from a slot\n  const handleSlotReset = slotId => {\n    const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n    if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId) {\n      const tileId = sentenceSlots[slotIndex].tileId;\n\n      // Clear the slot\n      const newSlots = [...sentenceSlots];\n      newSlots[slotIndex] = {\n        ...newSlots[slotIndex],\n        tileId: null,\n        wordTile: null\n      };\n      setSentenceSlots(newSlots);\n\n      // Mark the tile as available again\n      const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n      const newTiles = [...wordTiles];\n      newTiles[tileIndex] = {\n        ...newTiles[tileIndex],\n        isUsed: false\n      };\n      setWordTiles(newTiles);\n    }\n  };\n\n  // Check if the sentence is correct\n  const checkSentence = currentSlots => {\n    const correctOrder = getCorrectOrder(mode, isVersion2);\n\n    // Extract tileIds from the slots\n    const currentOrderIds = currentSlots.map(slot => slot.wordTile ? slot.wordTile.tileId : null);\n    const isCorrect = correctOrder.every((tileId, index) => currentOrderIds[index] === tileId);\n    if (isCorrect) {\n      const trialScore = Math.max(POINTS_PER_QUESTION - (MAX_TRIES - triesLeft) * PENALTY_PER_TRY, 0);\n      setScore(score + trialScore);\n      setFeedback('Correct! Moving to next image...');\n      setResults([...results, {\n        image: currentImage,\n        mode,\n        triesUsed: MAX_TRIES - triesLeft,\n        score: trialScore,\n        timestamp: new Date().toISOString()\n      }]);\n      setTimeout(() => {\n        if (currentTrial < sentences.length - 1) {\n          setCurrentTrial(currentTrial + 1);\n          setFeedback('');\n        } else {\n          setIsComplete(true);\n        }\n      }, 1500);\n    } else {\n      setIsError(true);\n      setTriesLeft(triesLeft - 1);\n      if (triesLeft <= 1) {\n        setFeedback('Out of tries. Moving to next question...');\n        setTimeout(() => {\n          if (currentTrial < sentences.length - 1) {\n            setCurrentTrial(currentTrial + 1);\n            setFeedback('');\n          } else {\n            setIsComplete(true);\n          }\n        }, 1500);\n      } else {\n        setFeedback(`Incorrect! ${triesLeft - 1} tries left`);\n        setTimeout(() => setIsError(false), 1000);\n      }\n    }\n  };\n\n  // Helper function to shuffle array\n  const shuffleArray = array => {\n    const newArray = [...array];\n    for (let i = newArray.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n    }\n    return newArray;\n  };\n\n  // Function to download results as CSV\n  const downloadResults = () => {\n    const csv = [['Image', 'Mode', 'Tries Used', 'Score', 'Timestamp'], ...results.map(r => [r.image, r.mode, r.triesUsed, r.score, r.timestamp])].map(row => row.join(',')).join('\\n');\n    const blob = new Blob([csv], {\n      type: 'text/csv'\n    });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = 'grammar_game_results.csv';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  };\n\n  // Game complete screen\n  if (isComplete) {\n    const averageTries = (results.reduce((sum, r) => sum + r.triesUsed, 0) / results.length).toFixed(1);\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        className: \"game-title\",\n        children: \"Game Complete\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 306,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"game-score\",\n        children: [\"Final Score: \", score, /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 309,\n          columnNumber: 21\n        }, this), \"Average tries per question: \", averageTries]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 307,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"mode-button\",\n        onClick: downloadResults,\n        children: \"Download Results\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 312,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 305,\n      columnNumber: 13\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => window.location.href = '/',\n      className: \"back-button\",\n      children: \"Back\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 324,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"game-title\",\n      children: \"Grammar Sentence Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 330,\n      columnNumber: 13\n    }, this), !mode ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mode-selection\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Choose your practice mode:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 335,\n        columnNumber: 21\n      }, this), Object.values(MODES).map(modeOption => /*#__PURE__*/_jsxDEV(\"button\", {\n        className: `mode-button ${mode === modeOption ? 'selected' : ''}`,\n        onClick: () => setMode(modeOption),\n        children: modeOption\n      }, modeOption, false, {\n        fileName: _jsxFileName,\n        lineNumber: 337,\n        columnNumber: 25\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 334,\n      columnNumber: 17\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-score\",\n        children: [\"Score: \", score, /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 350,\n          columnNumber: 25\n        }, this), \"Question \", currentTrial + 1, \" of \", sentences.length]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 348,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tries-counter\",\n        children: [\"Tries Left: \", triesLeft]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 353,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-container\",\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: currentImage,\n          alt: \"Scene to describe\",\n          className: \"prompt-image\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 359,\n          columnNumber: 25\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 358,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"sentence-slots\",\n        children: sentenceSlots.map(slot => /*#__PURE__*/_jsxDEV(SentenceSlot, {\n          id: slot.id,\n          tile: slot.wordTile,\n          isError: isError,\n          onClick: () => slot.wordTile ? handleSlotReset(slot.id) : handleSlotClick(slot.id)\n        }, slot.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 369,\n          columnNumber: 29\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 367,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"word-tiles\",\n        children: wordTiles.map(tile => /*#__PURE__*/_jsxDEV(WordTile, {\n          id: tile.id,\n          imagePath: tile.imagePath,\n          isUsed: tile.isUsed,\n          isSelected: selectedTile === tile.id,\n          onClick: () => handleTileClick(tile.id)\n        }, tile.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 384,\n          columnNumber: 29\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 382,\n        columnNumber: 21\n      }, this), feedback && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `feedback ${isError ? 'error' : 'success'}`,\n        children: feedback\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 396,\n        columnNumber: 25\n      }, this)]\n    }, void 0, true)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 323,\n    columnNumber: 9\n  }, this);\n}\n_s(GrammarGame, \"3iEl0IBhuAwGANsJTy54o3D6hWU=\");\n_c = GrammarGame;\nexport default GrammarGame;\nvar _c;\n$RefreshReg$(_c, \"GrammarGame\");","map":{"version":3,"names":["React","useState","useEffect","Papa","WordTile","SentenceSlot","jsxDEV","_jsxDEV","Fragment","_Fragment","MODES","PASSIVE","IMPERFECT","OBJECT_CLEFT","WH_QUESTION","MAX_TRIES","POINTS_PER_QUESTION","PENALTY_PER_TRY","GrammarGame","_s","mode","setMode","sentences","setSentences","currentTrial","setCurrentTrial","currentImage","setCurrentImage","isVersion2","setIsVersion2","score","setScore","triesLeft","setTriesLeft","feedback","setFeedback","isError","setIsError","isComplete","setIsComplete","results","setResults","wordTiles","setWordTiles","sentenceSlots","setSentenceSlots","selectedTile","setSelectedTile","loadSentences","response","fetch","csvText","text","parse","header","skipEmptyLines","complete","data","error","console","getCorrectOrder","gameMode","version2","length","setupNewTrial","sentence","Picture","includes","pictureId","trim","imagePath","tileOrder","modeFolderMap","modeFolder","toLowerCase","shuffledTiles","shuffleArray","map","tileId","index","id","isUsed","newSlots","_","position","wordTile","handleTileClick","tileIndex","findIndex","t","handleSlotClick","slotId","slotIndex","s","newTiles","every","slot","checkSentence","handleSlotReset","currentSlots","correctOrder","currentOrderIds","isCorrect","trialScore","Math","max","image","triesUsed","timestamp","Date","toISOString","setTimeout","array","newArray","i","j","floor","random","downloadResults","csv","r","row","join","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","averageTries","reduce","sum","toFixed","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","window","location","Object","values","modeOption","src","alt","tile","isSelected","_c","$RefreshReg$"],"sources":["/Users/peterpressman/MyDevelopment/JavaScript/SynTactic-online/syntactile-words/src/components/GrammarGame.js"],"sourcesContent":["// src/GrammarGame.js\nimport React, { useState, useEffect } from 'react';\nimport Papa from 'papaparse';\nimport WordTile from './WordTile';\nimport SentenceSlot from './SentenceSlot';\nimport '.GrammarGame.css';\n\nconst MODES = {\n    PASSIVE: 'Passive Voice',\n    IMPERFECT: 'Imperfect Tense',\n    OBJECT_CLEFT: 'Object Cleft',\n    WH_QUESTION: 'Wh Questions'\n};\n\nconst MAX_TRIES = 3;\nconst POINTS_PER_QUESTION = 10;\nconst PENALTY_PER_TRY = 3;\n\nfunction GrammarGame() {\n    // Game state\n    const [mode, setMode] = useState(null);\n    const [sentences, setSentences] = useState([]);\n    const [currentTrial, setCurrentTrial] = useState(0);\n    const [currentImage, setCurrentImage] = useState(null);\n    const [isVersion2, setIsVersion2] = useState(false);\n    const [score, setScore] = useState(0);\n    const [triesLeft, setTriesLeft] = useState(MAX_TRIES);\n    const [feedback, setFeedback] = useState('');\n    const [isError, setIsError] = useState(false);\n    const [isComplete, setIsComplete] = useState(false);\n    const [results, setResults] = useState([]);\n\n    // Tiles and slots state\n    const [wordTiles, setWordTiles] = useState([]);\n    const [sentenceSlots, setSentenceSlots] = useState([]);\n    const [selectedTile, setSelectedTile] = useState(null);\n\n    // Load sentences from CSV\n    useEffect(() => {\n        loadSentences();\n    }, []);\n\n    const loadSentences = async () => {\n        try {\n            const response = await fetch('/sentences_corrected.csv');\n            const csvText = await response.text();\n            \n            Papa.parse(csvText, {\n                header: true,\n                skipEmptyLines: true,\n                complete: (results) => {\n                    setSentences(results.data);\n                }\n            });\n        } catch (error) {\n            console.error('Error loading CSV:', error);\n        }\n    };\n\n    // Get the correct order of tiles based on mode and version\n    const getCorrectOrder = (gameMode, version2) => {\n        switch(gameMode) {\n            case MODES.IMPERFECT:\n                return version2 ? \n                    ['A2', 'A5', 'A3', 'A1'] :  // Version 2\n                    ['A1', 'A5', 'A3', 'A2'];   // Version 1\n            case MODES.PASSIVE:\n                return version2 ?\n                    ['A1', 'A5', 'A4', 'A6', 'A2', 'A3'] :  // Version 2\n                    ['A2', 'A5', 'A4', 'A6', 'A1', 'A3'];   // Version 1\n            case MODES.OBJECT_CLEFT:\n                return version2 ?\n                    ['A4', 'A2', 'A5', 'A3', 'A1'] :  // Version 2\n                    ['A4', 'A1', 'A5', 'A3', 'A2'];   // Version 1\n            case MODES.WH_QUESTION:\n                return version2 ?\n                    ['A5', 'A4', 'A2', 'A3', 'A1', 'A6'] :  // Version 2\n                    ['A5', 'A4', 'A1', 'A3', 'A2', 'A6'];   // Version 1\n            default:\n                return [];\n        }\n    };\n\n    // Setup a new trial when mode or currentTrial changes\n    useEffect(() => {\n        if (mode && sentences.length > 0) {\n            setupNewTrial();\n        }\n    }, [mode, currentTrial, sentences]);\n\n    const setupNewTrial = () => {\n        if (!sentences[currentTrial]) return;\n        \n        const sentence = sentences[currentTrial];\n        const version2 = sentence.Picture.includes(\"2\");\n        setIsVersion2(version2);\n        \n        const pictureId = sentence.Picture.trim();\n        const imagePath = `/images/Pic${pictureId}.jpg`;\n        setCurrentImage(imagePath);\n        \n        const tileOrder = getCorrectOrder(mode, version2);\n        \n        // Define mode-to-folder mapping\n        const modeFolderMap = {\n            \"Passive Voice\": \"passive\",\n            \"Imperfect Tense\": \"imperfect\",\n            \"Object Cleft\": \"object_cleft\",\n            \"Wh Questions\": \"wh_questions\"\n        };\n        \n        // Ensure mode maps to the correct folder name\n        const modeFolder = modeFolderMap[mode] || mode.toLowerCase();\n        \n        // Create shuffled tiles\n        const shuffledTiles = shuffleArray(\n            tileOrder.map((tileId, index) => ({\n                id: `tile-${index}`,\n                tileId: tileId,\n                imagePath: `/tiles/${modeFolder}/${tileId}.png`,\n                isUsed: false\n            }))\n        );\n        \n        setWordTiles(shuffledTiles);\n        \n        // Create empty sentence slots\n        const newSlots = tileOrder.map((_, index) => ({\n            id: `slot-${index}`,\n            position: index,\n            tileId: null,\n            wordTile: null\n        }));\n        \n        setSentenceSlots(newSlots);\n        setTriesLeft(MAX_TRIES);\n        setFeedback('');\n        setIsError(false);\n        setSelectedTile(null);\n    };\n\n    // Handle tile selection\n    const handleTileClick = (tileId) => {\n        const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n        if (tileIndex !== -1 && !wordTiles[tileIndex].isUsed) {\n            setSelectedTile(tileId);\n        }\n    };\n\n    // Handle slot click - place a selected tile in a slot\n    const handleSlotClick = (slotId) => {\n        if (!selectedTile) return;\n        \n        const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n        \n        // Only allow placement in empty slots\n        if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId === null) {\n            // Find the tile\n            const tileIndex = wordTiles.findIndex(t => t.id === selectedTile);\n            \n            // Update slots with the placed tile\n            const newSlots = [...sentenceSlots];\n            newSlots[slotIndex] = {\n                ...newSlots[slotIndex],\n                tileId: selectedTile,\n                wordTile: wordTiles[tileIndex]\n            };\n            setSentenceSlots(newSlots);\n            \n            // Mark the tile as used\n            const newTiles = [...wordTiles];\n            newTiles[tileIndex] = {\n                ...newTiles[tileIndex],\n                isUsed: true\n            };\n            setWordTiles(newTiles);\n            \n            // Clear selection\n            setSelectedTile(null);\n            \n            // Check if sentence is complete\n            if (newSlots.every(slot => slot.wordTile !== null)) {\n                checkSentence(newSlots);\n            }\n        }\n    };\n\n    // Remove a tile from a slot\n    const handleSlotReset = (slotId) => {\n        const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n        if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId) {\n            const tileId = sentenceSlots[slotIndex].tileId;\n            \n            // Clear the slot\n            const newSlots = [...sentenceSlots];\n            newSlots[slotIndex] = {\n                ...newSlots[slotIndex],\n                tileId: null,\n                wordTile: null\n            };\n            setSentenceSlots(newSlots);\n            \n            // Mark the tile as available again\n            const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n            const newTiles = [...wordTiles];\n            newTiles[tileIndex] = {\n                ...newTiles[tileIndex],\n                isUsed: false\n            };\n            setWordTiles(newTiles);\n        }\n    };\n\n    // Check if the sentence is correct\n    const checkSentence = (currentSlots) => {\n        const correctOrder = getCorrectOrder(mode, isVersion2);\n        \n        // Extract tileIds from the slots\n        const currentOrderIds = currentSlots.map(slot => \n            slot.wordTile ? slot.wordTile.tileId : null\n        );\n        \n        const isCorrect = correctOrder.every((tileId, index) => \n            currentOrderIds[index] === tileId\n        );\n\n        if (isCorrect) {\n            const trialScore = Math.max(\n                POINTS_PER_QUESTION - ((MAX_TRIES - triesLeft) * PENALTY_PER_TRY), \n                0\n            );\n            setScore(score + trialScore);\n            setFeedback('Correct! Moving to next image...');\n            \n            setResults([...results, {\n                image: currentImage,\n                mode,\n                triesUsed: MAX_TRIES - triesLeft,\n                score: trialScore,\n                timestamp: new Date().toISOString()\n            }]);\n\n            setTimeout(() => {\n                if (currentTrial < sentences.length - 1) {\n                    setCurrentTrial(currentTrial + 1);\n                    setFeedback('');\n                } else {\n                    setIsComplete(true);\n                }\n            }, 1500);\n        } else {\n            setIsError(true);\n            setTriesLeft(triesLeft - 1);\n            \n            if (triesLeft <= 1) {\n                setFeedback('Out of tries. Moving to next question...');\n                setTimeout(() => {\n                    if (currentTrial < sentences.length - 1) {\n                        setCurrentTrial(currentTrial + 1);\n                        setFeedback('');\n                    } else {\n                        setIsComplete(true);\n                    }\n                }, 1500);\n            } else {\n                setFeedback(`Incorrect! ${triesLeft - 1} tries left`);\n                setTimeout(() => setIsError(false), 1000);\n            }\n        }\n    };\n\n    // Helper function to shuffle array\n    const shuffleArray = (array) => {\n        const newArray = [...array];\n        for (let i = newArray.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n        }\n        return newArray;\n    };\n\n    // Function to download results as CSV\n    const downloadResults = () => {\n        const csv = [\n            ['Image', 'Mode', 'Tries Used', 'Score', 'Timestamp'],\n            ...results.map(r => [\n                r.image, r.mode, r.triesUsed, r.score, r.timestamp\n            ])\n        ].map(row => row.join(',')).join('\\n');\n\n        const blob = new Blob([csv], { type: 'text/csv' });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = 'grammar_game_results.csv';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    };\n\n    // Game complete screen\n    if (isComplete) {\n        const averageTries = (results.reduce((sum, r) => sum + r.triesUsed, 0) / results.length).toFixed(1);\n        return (\n            <div className=\"game-container\">\n                <h1 className=\"game-title\">Game Complete</h1>\n                <p className=\"game-score\">\n                    Final Score: {score}\n                    <br />\n                    Average tries per question: {averageTries}\n                </p>\n                <button \n                    className=\"mode-button\"\n                    onClick={downloadResults}\n                >\n                    Download Results\n                </button>\n            </div>\n        );\n    }\n\n    return (\n        <div className=\"game-container\">\n            <button \n                onClick={() => window.location.href = '/'}\n                className=\"back-button\"\n            >\n                Back\n            </button>\n            <h1 className=\"game-title\">Grammar Sentence Game</h1>\n            \n            {/* Mode selection */}\n            {!mode ? (\n                <div className=\"mode-selection\">\n                    <h2>Choose your practice mode:</h2>\n                    {Object.values(MODES).map((modeOption) => (\n                        <button\n                            key={modeOption}\n                            className={`mode-button ${mode === modeOption ? 'selected' : ''}`}\n                            onClick={() => setMode(modeOption)}\n                        >\n                            {modeOption}\n                        </button>\n                    ))}\n                </div>\n            ) : (\n                <>\n                    <div className=\"game-score\">\n                        Score: {score}\n                        <br />\n                        Question {currentTrial + 1} of {sentences.length}\n                    </div>\n                    <div className=\"tries-counter\">\n                        Tries Left: {triesLeft}\n                    </div>\n                    \n                    {/* Image prompt */}\n                    <div className=\"image-container\">\n                        <img\n                            src={currentImage}\n                            alt=\"Scene to describe\"\n                            className=\"prompt-image\"\n                        />\n                    </div>\n                    \n                    {/* Sentence slots */}\n                    <div className=\"sentence-slots\">\n                        {sentenceSlots.map(slot => (\n                            <SentenceSlot\n                                key={slot.id}\n                                id={slot.id}\n                                tile={slot.wordTile}\n                                isError={isError}\n                                onClick={() => slot.wordTile \n                                    ? handleSlotReset(slot.id) \n                                    : handleSlotClick(slot.id)}\n                            />\n                        ))}\n                    </div>\n                    \n                    {/* Word tiles */}\n                    <div className=\"word-tiles\">\n                        {wordTiles.map(tile => (\n                            <WordTile\n                                key={tile.id}\n                                id={tile.id}\n                                imagePath={tile.imagePath}\n                                isUsed={tile.isUsed}\n                                isSelected={selectedTile === tile.id}\n                                onClick={() => handleTileClick(tile.id)}\n                            />\n                        ))}\n                    </div>\n                    \n                    {feedback && (\n                        <div className={`feedback ${isError ? 'error' : 'success'}`}>\n                            {feedback}\n                        </div>\n                    )}\n                </>\n            )}\n        </div>\n    );\n}\n\nexport default GrammarGame;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}