{"ast":null,"code":"// src/components/GrammarGame.js\nimport React,{useState,useEffect}from'react';import Papa from'papaparse';import WordTile from'./WordTile';import SentenceSlot from'./SentenceSlot';import'./GrammarGame.css';import{jsx as _jsx,jsxs as _jsxs,Fragment as _Fragment}from\"react/jsx-runtime\";const MODES={PASSIVE:'Passive Voice',IMPERFECT:'Imperfect Tense',OBJECT_CLEFT:'Object Cleft',WH_QUESTION:'Wh Questions'};const MAX_TRIES=3;const POINTS_PER_QUESTION=10;const PENALTY_PER_TRY=3;function GrammarGame(){// Game state\nconst[mode,setMode]=useState(null);const[sentences,setSentences]=useState([]);const[availableSentences,setAvailableSentences]=useState([]);const[currentImage,setCurrentImage]=useState(null);const[isVersion2,setIsVersion2]=useState(false);const[score,setScore]=useState(0);const[triesLeft,setTriesLeft]=useState(MAX_TRIES);const[feedback,setFeedback]=useState('');const[isError,setIsError]=useState(false);const[isComplete,setIsComplete]=useState(false);const[results,setResults]=useState([]);// Tiles and slots state\nconst[wordTiles,setWordTiles]=useState([]);const[sentenceSlots,setSentenceSlots]=useState([]);const[selectedTile,setSelectedTile]=useState(null);// Load sentences from CSV\nuseEffect(()=>{loadSentences();},[]);const loadSentences=async()=>{try{const response=await fetch('/sentences_corrected.csv');const csvText=await response.text();Papa.parse(csvText,{header:true,skipEmptyLines:true,complete:results=>{// Store all sentences\nsetSentences(results.data);// Also create a randomized copy for selection\nsetAvailableSentences(shuffleArray([...results.data]));}});}catch(error){console.error('Error loading CSV:',error);}};// Function to get correct order based on mode, version, and picture prefix\nconst getCorrectOrder=(gameMode,version2,pictureId)=>{// Extract prefix (A, B, etc.) from the pictureId\nconst prefix=pictureId.charAt(0);switch(gameMode){case MODES.IMPERFECT:return version2?[`${prefix}2`,`${prefix}5`,`${prefix}3`,`${prefix}1`]:[`${prefix}1`,`${prefix}5`,`${prefix}3`,`${prefix}2`];case MODES.PASSIVE:return version2?[`${prefix}1`,`${prefix}5`,`${prefix}4`,`${prefix}6`,`${prefix}2`]:[`${prefix}2`,`${prefix}5`,`${prefix}4`,`${prefix}6`,`${prefix}1`];case MODES.OBJECT_CLEFT:return version2?[`${prefix}4`,`${prefix}2`,`${prefix}5`,`${prefix}3`,`${prefix}1`]:[`${prefix}4`,`${prefix}1`,`${prefix}5`,`${prefix}3`,`${prefix}2`];case MODES.WH_QUESTION:return version2?[`${prefix}5`,`${prefix}4`,`${prefix}2`,`${prefix}3`,`${prefix}1`,`${prefix}6`]:[`${prefix}5`,`${prefix}4`,`${prefix}1`,`${prefix}3`,`${prefix}2`,`${prefix}6`];default:return[];}};// Setup a new trial when mode or availableSentences changes\nuseEffect(()=>{if(mode&&availableSentences.length>0){setupNewTrial();}},[mode,availableSentences]);const setupNewTrial=()=>{if(availableSentences.length===0)return;// Get a sentence from the randomized array\nconst sentence=availableSentences[0];const pictureId=sentence.Picture.trim();const version2=pictureId.includes(\"2\");setIsVersion2(version2);const imagePath=`/images/Pic${pictureId}.jpg`;setCurrentImage(imagePath);// Get the correct tile order with the picture prefix\nconst tileOrder=getCorrectOrder(mode,version2,pictureId);// Map folders to modes\nconst modeFolderMap={\"Passive Voice\":\"passive\",\"Imperfect Tense\":\"imperfect\",\"Object Cleft\":\"object_cleft\",\"Wh Questions\":\"wh_questions\"};const modeFolder=modeFolderMap[mode]||mode.toLowerCase();// Create tiles with the correct prefix\nconst shuffledTiles=shuffleArray(tileOrder.map((tileId,index)=>({id:`tile-${index}`,tileId:tileId,imagePath:`/tiles/${modeFolder}/${tileId}.png`,isUsed:false})));setWordTiles(shuffledTiles);// Create empty sentence slots\nconst newSlots=tileOrder.map((_,index)=>({id:`slot-${index}`,position:index,tileId:null,wordTile:null}));setSentenceSlots(newSlots);setTriesLeft(MAX_TRIES);setFeedback('');setIsError(false);setSelectedTile(null);};// Handle tile selection\nconst handleTileClick=tileId=>{const tileIndex=wordTiles.findIndex(t=>t.id===tileId);if(tileIndex!==-1&&!wordTiles[tileIndex].isUsed){setSelectedTile(tileId);}};// Handle slot click - place a selected tile in a slot\nconst handleSlotClick=slotId=>{if(!selectedTile)return;const slotIndex=sentenceSlots.findIndex(s=>s.id===slotId);// Only allow placement in empty slots\nif(slotIndex!==-1&&sentenceSlots[slotIndex].tileId===null){// Find the tile\nconst tileIndex=wordTiles.findIndex(t=>t.id===selectedTile);// Update slots with the placed tile\nconst newSlots=[...sentenceSlots];newSlots[slotIndex]={...newSlots[slotIndex],tileId:selectedTile,wordTile:wordTiles[tileIndex]};setSentenceSlots(newSlots);// Mark the tile as used\nconst newTiles=[...wordTiles];newTiles[tileIndex]={...newTiles[tileIndex],isUsed:true};setWordTiles(newTiles);// Clear selection\nsetSelectedTile(null);// Check if sentence is complete\nif(newSlots.every(slot=>slot.wordTile!==null)){checkSentence(newSlots);}}};// Remove a tile from a slot\nconst handleSlotReset=slotId=>{const slotIndex=sentenceSlots.findIndex(s=>s.id===slotId);if(slotIndex!==-1&&sentenceSlots[slotIndex].tileId){const tileId=sentenceSlots[slotIndex].tileId;// Clear the slot\nconst newSlots=[...sentenceSlots];newSlots[slotIndex]={...newSlots[slotIndex],tileId:null,wordTile:null};setSentenceSlots(newSlots);// Mark the tile as available again\nconst tileIndex=wordTiles.findIndex(t=>t.id===tileId);const newTiles=[...wordTiles];newTiles[tileIndex]={...newTiles[tileIndex],isUsed:false};setWordTiles(newTiles);}};// Check if the sentence is correct\nconst checkSentence=currentSlots=>{// Get the current sentence\nconst sentence=availableSentences[0];const pictureId=sentence.Picture.trim();// Get the correct order using the picture ID\nconst correctOrder=getCorrectOrder(mode,isVersion2,pictureId);// Extract tileIds from the slots\nconst currentOrderIds=currentSlots.map(slot=>slot.wordTile?slot.wordTile.tileId:null);const isCorrect=correctOrder.every((tileId,index)=>currentOrderIds[index]===tileId);if(isCorrect){const trialScore=Math.max(POINTS_PER_QUESTION-(MAX_TRIES-triesLeft)*PENALTY_PER_TRY,0);setScore(score+trialScore);setFeedback('Correct! Moving to next image...');setResults([...results,{image:currentImage,mode,triesUsed:MAX_TRIES-triesLeft,score:trialScore,timestamp:new Date().toISOString()}]);setTimeout(()=>{if(availableSentences.length>1){// Remove the current sentence from available pool\nconst newAvailableSentences=[...availableSentences.slice(1)];setAvailableSentences(newAvailableSentences);setFeedback('');}else{setIsComplete(true);}},1500);}else{setIsError(true);setTriesLeft(triesLeft-1);if(triesLeft<=1){setFeedback('Out of tries. Moving to next question...');setTimeout(()=>{if(availableSentences.length>1){// Remove the current sentence from available pool\nconst newAvailableSentences=[...availableSentences.slice(1)];setAvailableSentences(newAvailableSentences);setFeedback('');}else{setIsComplete(true);}},1500);}else{setFeedback(`Incorrect! ${triesLeft-1} tries left`);setTimeout(()=>setIsError(false),1000);}}};// Helper function to shuffle array\nconst shuffleArray=array=>{const newArray=[...array];for(let i=newArray.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[newArray[i],newArray[j]]=[newArray[j],newArray[i]];}return newArray;};// Function to download results as CSV\nconst downloadResults=()=>{const csv=[['Image','Mode','Tries Used','Score','Timestamp'],...results.map(r=>[r.image,r.mode,r.triesUsed,r.score,r.timestamp])].map(row=>row.join(',')).join('\\n');const blob=new Blob([csv],{type:'text/csv'});const url=URL.createObjectURL(blob);const link=document.createElement('a');link.href=url;link.download='grammar_game_results.csv';document.body.appendChild(link);link.click();document.body.removeChild(link);};// Game complete screen\nif(isComplete){const averageTries=(results.reduce((sum,r)=>sum+r.triesUsed,0)/results.length).toFixed(1);return/*#__PURE__*/_jsxs(\"div\",{className:\"game-container\",children:[/*#__PURE__*/_jsx(\"h1\",{className:\"game-title\",children:\"Game Complete\"}),/*#__PURE__*/_jsxs(\"p\",{className:\"game-score\",children:[\"Final Score: \",score,/*#__PURE__*/_jsx(\"br\",{}),\"Average tries per question: \",averageTries]}),/*#__PURE__*/_jsx(\"button\",{className:\"mode-button\",onClick:downloadResults,children:\"Download Results\"})]});}return/*#__PURE__*/_jsxs(\"div\",{className:\"game-container\",children:[/*#__PURE__*/_jsx(\"button\",{onClick:()=>window.location.href='/',className:\"back-button\",children:\"Back\"}),/*#__PURE__*/_jsx(\"h1\",{className:\"game-title\",children:\"Grammar Sentence Game\"}),!mode?/*#__PURE__*/_jsxs(\"div\",{className:\"mode-selection\",children:[/*#__PURE__*/_jsx(\"h2\",{children:\"Choose your practice mode:\"}),Object.values(MODES).map(modeOption=>/*#__PURE__*/_jsx(\"button\",{className:`mode-button ${mode===modeOption?'selected':''}`,onClick:()=>setMode(modeOption),children:modeOption},modeOption))]}):/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsxs(\"div\",{className:\"game-score\",children:[\"Score: \",score,/*#__PURE__*/_jsx(\"br\",{}),\"Question \",sentences.length-availableSentences.length+1,\" of \",sentences.length]}),/*#__PURE__*/_jsxs(\"div\",{className:\"tries-counter\",children:[\"Tries Left: \",triesLeft]}),/*#__PURE__*/_jsx(\"div\",{className:\"image-container\",children:/*#__PURE__*/_jsx(\"img\",{src:currentImage,alt:\"Scene to describe\",className:\"prompt-image\"})}),/*#__PURE__*/_jsx(\"div\",{className:\"sentence-slots\",children:sentenceSlots.map(slot=>/*#__PURE__*/_jsx(SentenceSlot,{id:slot.id,tile:slot.wordTile,isError:isError,onClick:()=>slot.wordTile?handleSlotReset(slot.id):handleSlotClick(slot.id)},slot.id))}),/*#__PURE__*/_jsx(\"div\",{className:\"word-tiles\",children:wordTiles.map(tile=>/*#__PURE__*/_jsx(WordTile,{id:tile.id,imagePath:tile.imagePath,isUsed:tile.isUsed,isSelected:selectedTile===tile.id,onClick:()=>handleTileClick(tile.id)},tile.id))}),feedback&&/*#__PURE__*/_jsx(\"div\",{className:`feedback ${isError?'error':'success'}`,children:feedback})]})]});}export default GrammarGame;","map":{"version":3,"names":["React","useState","useEffect","Papa","WordTile","SentenceSlot","jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","MODES","PASSIVE","IMPERFECT","OBJECT_CLEFT","WH_QUESTION","MAX_TRIES","POINTS_PER_QUESTION","PENALTY_PER_TRY","GrammarGame","mode","setMode","sentences","setSentences","availableSentences","setAvailableSentences","currentImage","setCurrentImage","isVersion2","setIsVersion2","score","setScore","triesLeft","setTriesLeft","feedback","setFeedback","isError","setIsError","isComplete","setIsComplete","results","setResults","wordTiles","setWordTiles","sentenceSlots","setSentenceSlots","selectedTile","setSelectedTile","loadSentences","response","fetch","csvText","text","parse","header","skipEmptyLines","complete","data","shuffleArray","error","console","getCorrectOrder","gameMode","version2","pictureId","prefix","charAt","length","setupNewTrial","sentence","Picture","trim","includes","imagePath","tileOrder","modeFolderMap","modeFolder","toLowerCase","shuffledTiles","map","tileId","index","id","isUsed","newSlots","_","position","wordTile","handleTileClick","tileIndex","findIndex","t","handleSlotClick","slotId","slotIndex","s","newTiles","every","slot","checkSentence","handleSlotReset","currentSlots","correctOrder","currentOrderIds","isCorrect","trialScore","Math","max","image","triesUsed","timestamp","Date","toISOString","setTimeout","newAvailableSentences","slice","array","newArray","i","j","floor","random","downloadResults","csv","r","row","join","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","averageTries","reduce","sum","toFixed","className","children","onClick","window","location","Object","values","modeOption","src","alt","tile","isSelected"],"sources":["/Users/peterpressman/MyDevelopment/JavaScript/SynTactic-online/syntactile-words/src/components/GrammarGame.js"],"sourcesContent":["// src/components/GrammarGame.js\nimport React, { useState, useEffect } from 'react';\nimport Papa from 'papaparse';\nimport WordTile from './WordTile';\nimport SentenceSlot from './SentenceSlot';\nimport './GrammarGame.css';\n\nconst MODES = {\n    PASSIVE: 'Passive Voice',\n    IMPERFECT: 'Imperfect Tense',\n    OBJECT_CLEFT: 'Object Cleft',\n    WH_QUESTION: 'Wh Questions'\n};\n\nconst MAX_TRIES = 3;\nconst POINTS_PER_QUESTION = 10;\nconst PENALTY_PER_TRY = 3;\n\nfunction GrammarGame() {\n    // Game state\n    const [mode, setMode] = useState(null);\n    const [sentences, setSentences] = useState([]);\n    const [availableSentences, setAvailableSentences] = useState([]);\n    const [currentImage, setCurrentImage] = useState(null);\n    const [isVersion2, setIsVersion2] = useState(false);\n    const [score, setScore] = useState(0);\n    const [triesLeft, setTriesLeft] = useState(MAX_TRIES);\n    const [feedback, setFeedback] = useState('');\n    const [isError, setIsError] = useState(false);\n    const [isComplete, setIsComplete] = useState(false);\n    const [results, setResults] = useState([]);\n\n    // Tiles and slots state\n    const [wordTiles, setWordTiles] = useState([]);\n    const [sentenceSlots, setSentenceSlots] = useState([]);\n    const [selectedTile, setSelectedTile] = useState(null);\n\n    // Load sentences from CSV\n    useEffect(() => {\n        loadSentences();\n    }, []);\n\n    const loadSentences = async () => {\n        try {\n            const response = await fetch('/sentences_corrected.csv');\n            const csvText = await response.text();\n            \n            Papa.parse(csvText, {\n                header: true,\n                skipEmptyLines: true,\n                complete: (results) => {\n                    // Store all sentences\n                    setSentences(results.data);\n                    // Also create a randomized copy for selection\n                    setAvailableSentences(shuffleArray([...results.data]));\n                }\n            });\n        } catch (error) {\n            console.error('Error loading CSV:', error);\n        }\n    };\n\n    // Function to get correct order based on mode, version, and picture prefix\n    const getCorrectOrder = (gameMode, version2, pictureId) => {\n        // Extract prefix (A, B, etc.) from the pictureId\n        const prefix = pictureId.charAt(0);\n        \n        switch(gameMode) {\n            case MODES.IMPERFECT:\n                return version2 ? \n                    [`${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] :\n                    [`${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n            case MODES.PASSIVE:\n                return version2 ?\n                    [`${prefix}1`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}2`] :\n                    [`${prefix}2`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}1`];\n            case MODES.OBJECT_CLEFT:\n                return version2 ?\n                    [`${prefix}4`, `${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] :\n                    [`${prefix}4`, `${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n            case MODES.WH_QUESTION:\n                return version2 ?\n                    [`${prefix}5`, `${prefix}4`, `${prefix}2`, `${prefix}3`, `${prefix}1`, `${prefix}6`] :\n                    [`${prefix}5`, `${prefix}4`, `${prefix}1`, `${prefix}3`, `${prefix}2`, `${prefix}6`];\n            default:\n                return [];\n        }\n    };\n\n    // Setup a new trial when mode or availableSentences changes\n    useEffect(() => {\n        if (mode && availableSentences.length > 0) {\n            setupNewTrial();\n        }\n    }, [mode, availableSentences]);\n\n    const setupNewTrial = () => {\n        if (availableSentences.length === 0) return;\n        \n        // Get a sentence from the randomized array\n        const sentence = availableSentences[0];\n        const pictureId = sentence.Picture.trim();\n        const version2 = pictureId.includes(\"2\");\n        setIsVersion2(version2);\n        \n        const imagePath = `/images/Pic${pictureId}.jpg`;\n        setCurrentImage(imagePath);\n        \n        // Get the correct tile order with the picture prefix\n        const tileOrder = getCorrectOrder(mode, version2, pictureId);\n        \n        // Map folders to modes\n        const modeFolderMap = {\n            \"Passive Voice\": \"passive\",\n            \"Imperfect Tense\": \"imperfect\",\n            \"Object Cleft\": \"object_cleft\",\n            \"Wh Questions\": \"wh_questions\"\n        };\n        \n        const modeFolder = modeFolderMap[mode] || mode.toLowerCase();\n        \n        // Create tiles with the correct prefix\n        const shuffledTiles = shuffleArray(\n            tileOrder.map((tileId, index) => ({\n                id: `tile-${index}`,\n                tileId: tileId,\n                imagePath: `/tiles/${modeFolder}/${tileId}.png`,\n                isUsed: false\n            }))\n        );\n        \n        setWordTiles(shuffledTiles);\n        \n        // Create empty sentence slots\n        const newSlots = tileOrder.map((_, index) => ({\n            id: `slot-${index}`,\n            position: index,\n            tileId: null,\n            wordTile: null\n        }));\n        \n        setSentenceSlots(newSlots);\n        setTriesLeft(MAX_TRIES);\n        setFeedback('');\n        setIsError(false);\n        setSelectedTile(null);\n    };\n\n    // Handle tile selection\n    const handleTileClick = (tileId) => {\n        const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n        if (tileIndex !== -1 && !wordTiles[tileIndex].isUsed) {\n            setSelectedTile(tileId);\n        }\n    };\n\n    // Handle slot click - place a selected tile in a slot\n    const handleSlotClick = (slotId) => {\n        if (!selectedTile) return;\n        \n        const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n        \n        // Only allow placement in empty slots\n        if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId === null) {\n            // Find the tile\n            const tileIndex = wordTiles.findIndex(t => t.id === selectedTile);\n            \n            // Update slots with the placed tile\n            const newSlots = [...sentenceSlots];\n            newSlots[slotIndex] = {\n                ...newSlots[slotIndex],\n                tileId: selectedTile,\n                wordTile: wordTiles[tileIndex]\n            };\n            setSentenceSlots(newSlots);\n            \n            // Mark the tile as used\n            const newTiles = [...wordTiles];\n            newTiles[tileIndex] = {\n                ...newTiles[tileIndex],\n                isUsed: true\n            };\n            setWordTiles(newTiles);\n            \n            // Clear selection\n            setSelectedTile(null);\n            \n            // Check if sentence is complete\n            if (newSlots.every(slot => slot.wordTile !== null)) {\n                checkSentence(newSlots);\n            }\n        }\n    };\n\n    // Remove a tile from a slot\n    const handleSlotReset = (slotId) => {\n        const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n        if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId) {\n            const tileId = sentenceSlots[slotIndex].tileId;\n            \n            // Clear the slot\n            const newSlots = [...sentenceSlots];\n            newSlots[slotIndex] = {\n                ...newSlots[slotIndex],\n                tileId: null,\n                wordTile: null\n            };\n            setSentenceSlots(newSlots);\n            \n            // Mark the tile as available again\n            const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n            const newTiles = [...wordTiles];\n            newTiles[tileIndex] = {\n                ...newTiles[tileIndex],\n                isUsed: false\n            };\n            setWordTiles(newTiles);\n        }\n    };\n\n    // Check if the sentence is correct\n    const checkSentence = (currentSlots) => {\n        // Get the current sentence\n        const sentence = availableSentences[0];\n        const pictureId = sentence.Picture.trim();\n        \n        // Get the correct order using the picture ID\n        const correctOrder = getCorrectOrder(mode, isVersion2, pictureId);\n        \n        // Extract tileIds from the slots\n        const currentOrderIds = currentSlots.map(slot => \n            slot.wordTile ? slot.wordTile.tileId : null\n        );\n        \n        const isCorrect = correctOrder.every((tileId, index) => \n            currentOrderIds[index] === tileId\n        );\n\n        if (isCorrect) {\n            const trialScore = Math.max(\n                POINTS_PER_QUESTION - ((MAX_TRIES - triesLeft) * PENALTY_PER_TRY), \n                0\n            );\n            setScore(score + trialScore);\n            setFeedback('Correct! Moving to next image...');\n            \n            setResults([...results, {\n                image: currentImage,\n                mode,\n                triesUsed: MAX_TRIES - triesLeft,\n                score: trialScore,\n                timestamp: new Date().toISOString()\n            }]);\n\n            setTimeout(() => {\n                if (availableSentences.length > 1) {\n                    // Remove the current sentence from available pool\n                    const newAvailableSentences = [...availableSentences.slice(1)];\n                    setAvailableSentences(newAvailableSentences);\n                    setFeedback('');\n                } else {\n                    setIsComplete(true);\n                }\n            }, 1500);\n        } else {\n            setIsError(true);\n            setTriesLeft(triesLeft - 1);\n            \n            if (triesLeft <= 1) {\n                setFeedback('Out of tries. Moving to next question...');\n                setTimeout(() => {\n                    if (availableSentences.length > 1) {\n                        // Remove the current sentence from available pool\n                        const newAvailableSentences = [...availableSentences.slice(1)];\n                        setAvailableSentences(newAvailableSentences);\n                        setFeedback('');\n                    } else {\n                        setIsComplete(true);\n                    }\n                }, 1500);\n            } else {\n                setFeedback(`Incorrect! ${triesLeft - 1} tries left`);\n                setTimeout(() => setIsError(false), 1000);\n            }\n        }\n    };\n\n    // Helper function to shuffle array\n    const shuffleArray = (array) => {\n        const newArray = [...array];\n        for (let i = newArray.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n        }\n        return newArray;\n    };\n\n    // Function to download results as CSV\n    const downloadResults = () => {\n        const csv = [\n            ['Image', 'Mode', 'Tries Used', 'Score', 'Timestamp'],\n            ...results.map(r => [\n                r.image, r.mode, r.triesUsed, r.score, r.timestamp\n            ])\n        ].map(row => row.join(',')).join('\\n');\n\n        const blob = new Blob([csv], { type: 'text/csv' });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = 'grammar_game_results.csv';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    };\n\n    // Game complete screen\n    if (isComplete) {\n        const averageTries = (results.reduce((sum, r) => sum + r.triesUsed, 0) / results.length).toFixed(1);\n        return (\n            <div className=\"game-container\">\n                <h1 className=\"game-title\">Game Complete</h1>\n                <p className=\"game-score\">\n                    Final Score: {score}\n                    <br />\n                    Average tries per question: {averageTries}\n                </p>\n                <button \n                    className=\"mode-button\"\n                    onClick={downloadResults}\n                >\n                    Download Results\n                </button>\n            </div>\n        );\n    }\n\n    return (\n        <div className=\"game-container\">\n            <button \n                onClick={() => window.location.href = '/'}\n                className=\"back-button\"\n            >\n                Back\n            </button>\n            <h1 className=\"game-title\">Grammar Sentence Game</h1>\n            \n            {/* Mode selection */}\n            {!mode ? (\n                <div className=\"mode-selection\">\n                    <h2>Choose your practice mode:</h2>\n                    {Object.values(MODES).map((modeOption) => (\n                        <button\n                            key={modeOption}\n                            className={`mode-button ${mode === modeOption ? 'selected' : ''}`}\n                            onClick={() => setMode(modeOption)}\n                        >\n                            {modeOption}\n                        </button>\n                    ))}\n                </div>\n            ) : (\n                <>\n                    <div className=\"game-score\">\n                        Score: {score}\n                        <br />\n                        Question {sentences.length - availableSentences.length + 1} of {sentences.length}\n                    </div>\n                    <div className=\"tries-counter\">\n                        Tries Left: {triesLeft}\n                    </div>\n                    \n                    {/* Image prompt */}\n                    <div className=\"image-container\">\n                        <img\n                            src={currentImage}\n                            alt=\"Scene to describe\"\n                            className=\"prompt-image\"\n                        />\n                    </div>\n                    \n                    {/* Sentence slots */}\n                    <div className=\"sentence-slots\">\n                        {sentenceSlots.map(slot => (\n                            <SentenceSlot\n                                key={slot.id}\n                                id={slot.id}\n                                tile={slot.wordTile}\n                                isError={isError}\n                                onClick={() => slot.wordTile \n                                    ? handleSlotReset(slot.id) \n                                    : handleSlotClick(slot.id)}\n                            />\n                        ))}\n                    </div>\n                    \n                    {/* Word tiles */}\n                    <div className=\"word-tiles\">\n                        {wordTiles.map(tile => (\n                            <WordTile\n                                key={tile.id}\n                                id={tile.id}\n                                imagePath={tile.imagePath}\n                                isUsed={tile.isUsed}\n                                isSelected={selectedTile === tile.id}\n                                onClick={() => handleTileClick(tile.id)}\n                            />\n                        ))}\n                    </div>\n                    \n                    {feedback && (\n                        <div className={`feedback ${isError ? 'error' : 'success'}`}>\n                            {feedback}\n                        </div>\n                    )}\n                </>\n            )}\n        </div>\n    );\n}\n\nexport default GrammarGame;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}