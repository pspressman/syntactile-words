{"ast":null,"code":"var _jsxFileName = \"/Users/peterpressman/MyDevelopment/JavaScript/SynTactic-online/syntactile-words/src/components/GrammarGame.js\",\n  _s = $RefreshSig$();\n// src/components/GrammarGame.js\nimport React, { useState, useEffect } from 'react';\nimport Papa from 'papaparse';\nimport WordTile from './WordTile';\nimport SentenceSlot from './SentenceSlot';\nimport './GrammarGame.css';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODES = {\n  PASSIVE: 'Passive Voice',\n  IMPERFECT: 'Imperfect Tense',\n  OBJECT_CLEFT: 'Object Cleft',\n  WH_QUESTION: 'Wh Questions'\n};\nconst MAX_TRIES = 3;\nconst POINTS_PER_QUESTION = 10;\nconst PENALTY_PER_TRY = 3;\nfunction GrammarGame() {\n  _s();\n  // Game state\n  const [mode, setMode] = useState(null);\n  const [sentences, setSentences] = useState([]);\n  const [availableSentences, setAvailableSentences] = useState([]);\n  const [currentImage, setCurrentImage] = useState(null);\n  const [correctOrderForCurrentSentence, setCorrectOrderForCurrentSentence] = useState([]);\n  const [score, setScore] = useState(0);\n  const [triesLeft, setTriesLeft] = useState(MAX_TRIES);\n  const [feedback, setFeedback] = useState('');\n  const [isError, setIsError] = useState(false);\n  const [isComplete, setIsComplete] = useState(false);\n  const [results, setResults] = useState([]);\n\n  // Tiles and slots state\n  const [wordTiles, setWordTiles] = useState([]);\n  const [sentenceSlots, setSentenceSlots] = useState([]);\n  const [selectedTile, setSelectedTile] = useState(null);\n\n  // Load sentences from CSV\n  useEffect(() => {\n    loadSentences();\n  }, []);\n  const loadSentences = async () => {\n    try {\n      const response = await fetch('/sentences_corrected.csv');\n      const csvText = await response.text();\n      Papa.parse(csvText, {\n        header: true,\n        skipEmptyLines: true,\n        complete: results => {\n          // Store all sentences\n          setSentences(results.data);\n          // Also create a randomized copy for selection\n          setAvailableSentences(shuffleArray([...results.data]));\n        }\n      });\n    } catch (error) {\n      console.error('Error loading CSV:', error);\n    }\n  };\n\n  // Map CSV columns to mode names\n  const getModeColumn = mode => {\n    switch (mode) {\n      case MODES.PASSIVE:\n        return \"Passive\";\n      case MODES.IMPERFECT:\n        return \"Progressive Active\";\n      case MODES.OBJECT_CLEFT:\n        return \"Object Cleft\";\n      case MODES.WH_QUESTION:\n        return \"Wh Question\";\n      default:\n        return \"\";\n    }\n  };\n\n  // Get tile order based on mode and picture ID\n  const getCorrectOrder = (gameMode, pictureId) => {\n    const prefix = pictureId.charAt(0);\n    const version2 = pictureId.includes(\"2\");\n    switch (gameMode) {\n      case MODES.IMPERFECT:\n        return version2 ? [`${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] : [`${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n      case MODES.PASSIVE:\n        return version2 ? [`${prefix}1`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}2`] : [`${prefix}2`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}1`];\n      case MODES.OBJECT_CLEFT:\n        return version2 ? [`${prefix}4`, `${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] : [`${prefix}4`, `${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n      case MODES.WH_QUESTION:\n        return version2 ? [`${prefix}5`, `${prefix}4`, `${prefix}2`, `${prefix}3`, `${prefix}1`, `${prefix}6`] : [`${prefix}5`, `${prefix}4`, `${prefix}1`, `${prefix}3`, `${prefix}2`, `${prefix}6`];\n      default:\n        return [];\n    }\n  };\n\n  // Setup a new trial when mode or availableSentences changes\n  useEffect(() => {\n    if (mode && availableSentences.length > 0) {\n      setupNewTrial();\n    }\n  }, [mode, availableSentences]);\n  const setupNewTrial = () => {\n    if (availableSentences.length === 0) return;\n\n    // Get a sentence from the randomized array\n    const sentence = availableSentences[0];\n    const pictureId = sentence.Picture.trim();\n    const imagePath = `/images/Pic${pictureId}.jpg`;\n    setCurrentImage(imagePath);\n\n    // Get the correct tile order for this sentence\n    const correctOrder = getCorrectOrder(mode, pictureId);\n    console.log('Setting up trial for:', pictureId);\n    console.log('Expected order:', correctOrder);\n    setCorrectOrderForCurrentSentence(correctOrder);\n\n    // Map folders to modes\n    const modeFolderMap = {\n      \"Passive Voice\": \"passive\",\n      \"Imperfect Tense\": \"imperfect\",\n      \"Object Cleft\": \"object_cleft\",\n      \"Wh Questions\": \"wh_questions\"\n    };\n    const modeFolder = modeFolderMap[mode] || mode.toLowerCase();\n\n    // Create tiles with the correct prefix\n    const shuffledTiles = shuffleArray(correctOrder.map((tileId, index) => ({\n      id: `tile-${index}`,\n      tileId: tileId,\n      imagePath: `/tiles/${modeFolder}/${tileId}.png`,\n      isUsed: false\n    })));\n    setWordTiles(shuffledTiles);\n\n    // Create empty sentence slots\n    const newSlots = correctOrder.map((_, index) => ({\n      id: `slot-${index}`,\n      position: index,\n      tileId: null,\n      wordTile: null\n    }));\n    setSentenceSlots(newSlots);\n    setTriesLeft(MAX_TRIES);\n    setFeedback('');\n    setIsError(false);\n    setSelectedTile(null);\n  };\n\n  // Handle tile selection\n  const handleTileClick = tileId => {\n    const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n    if (tileIndex !== -1 && !wordTiles[tileIndex].isUsed) {\n      setSelectedTile(tileId);\n    }\n  };\n\n  // Handle slot click - place a selected tile in a slot\n  const handleSlotClick = slotId => {\n    if (!selectedTile) return;\n    const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n\n    // Only allow placement in empty slots\n    if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId === null) {\n      // Find the tile\n      const tileIndex = wordTiles.findIndex(t => t.id === selectedTile);\n\n      // Update slots with the placed tile\n      const newSlots = [...sentenceSlots];\n      newSlots[slotIndex] = {\n        ...newSlots[slotIndex],\n        tileId: selectedTile,\n        wordTile: wordTiles[tileIndex]\n      };\n      setSentenceSlots(newSlots);\n\n      // Mark the tile as used\n      const newTiles = [...wordTiles];\n      newTiles[tileIndex] = {\n        ...newTiles[tileIndex],\n        isUsed: true\n      };\n      setWordTiles(newTiles);\n\n      // Clear selection\n      setSelectedTile(null);\n\n      // Check if sentence is complete\n      if (newSlots.every(slot => slot.wordTile !== null)) {\n        checkSentence(newSlots);\n      }\n    }\n  };\n\n  // Remove a tile from a slot\n  const handleSlotReset = slotId => {\n    const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n    if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId) {\n      const tileId = sentenceSlots[slotIndex].tileId;\n\n      // Clear the slot\n      const newSlots = [...sentenceSlots];\n      newSlots[slotIndex] = {\n        ...newSlots[slotIndex],\n        tileId: null,\n        wordTile: null\n      };\n      setSentenceSlots(newSlots);\n\n      // Mark the tile as available again\n      const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n      const newTiles = [...wordTiles];\n      newTiles[tileIndex] = {\n        ...newTiles[tileIndex],\n        isUsed: false\n      };\n      setWordTiles(newTiles);\n    }\n  };\n\n  // Check if the sentence is correct\n  const checkSentence = currentSlots => {\n    // Compare the current order with the correct order that was \n    // stored during setupNewTrial\n\n    // Extract tileIds from the slots\n    const currentOrderIds = currentSlots.map(slot => slot.wordTile ? slot.wordTile.tileId : null);\n    console.log('User arrangement:', currentOrderIds);\n    console.log('Expected arrangement:', correctOrderForCurrentSentence);\n\n    // Compare with the correct order for this sentence\n    let isCorrect = true;\n    for (let i = 0; i < correctOrderForCurrentSentence.length; i++) {\n      if (currentOrderIds[i] !== correctOrderForCurrentSentence[i]) {\n        isCorrect = false;\n        break;\n      }\n    }\n    if (isCorrect) {\n      const trialScore = Math.max(POINTS_PER_QUESTION - (MAX_TRIES - triesLeft) * PENALTY_PER_TRY, 0);\n      setScore(score + trialScore);\n      setFeedback('Correct! Moving to next image...');\n      setResults([...results, {\n        image: currentImage,\n        mode,\n        triesUsed: MAX_TRIES - triesLeft,\n        score: trialScore,\n        timestamp: new Date().toISOString()\n      }]);\n      setTimeout(() => {\n        if (availableSentences.length > 1) {\n          // Remove the current sentence from available pool\n          const newAvailableSentences = [...availableSentences.slice(1)];\n          setAvailableSentences(newAvailableSentences);\n          setFeedback('');\n        } else {\n          setIsComplete(true);\n        }\n      }, 1500);\n    } else {\n      setIsError(true);\n      setTriesLeft(triesLeft - 1);\n      if (triesLeft <= 1) {\n        setFeedback('Out of tries. Moving to next question...');\n        setTimeout(() => {\n          if (availableSentences.length > 1) {\n            // Remove the current sentence from available pool\n            const newAvailableSentences = [...availableSentences.slice(1)];\n            setAvailableSentences(newAvailableSentences);\n            setFeedback('');\n          } else {\n            setIsComplete(true);\n          }\n        }, 1500);\n      } else {\n        setFeedback(`Incorrect! ${triesLeft - 1} tries left`);\n        setTimeout(() => setIsError(false), 1000);\n      }\n    }\n  };\n\n  // Helper function to shuffle array\n  const shuffleArray = array => {\n    const newArray = [...array];\n    for (let i = newArray.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n    }\n    return newArray;\n  };\n\n  // Function to download results as CSV\n  const downloadResults = () => {\n    const csv = [['Image', 'Mode', 'Tries Used', 'Score', 'Timestamp'], ...results.map(r => [r.image, r.mode, r.triesUsed, r.score, r.timestamp])].map(row => row.join(',')).join('\\n');\n    const blob = new Blob([csv], {\n      type: 'text/csv'\n    });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = 'grammar_game_results.csv';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  };\n\n  // Game complete screen\n  if (isComplete) {\n    const averageTries = (results.reduce((sum, r) => sum + r.triesUsed, 0) / results.length).toFixed(1);\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        className: \"game-title\",\n        children: \"Game Complete\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 340,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"game-score\",\n        children: [\"Final Score: \", score, /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 343,\n          columnNumber: 21\n        }, this), \"Average tries per question: \", averageTries]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 341,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"mode-button\",\n        onClick: downloadResults,\n        children: \"Download Results\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 346,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"back-to-hub\",\n        children: /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"back-button\",\n          onClick: () => window.location.href = 'https://syntactic-hub.vercel.app',\n          children: \"Back to Syntactic Hub\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 353,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 352,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 339,\n      columnNumber: 13\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => window.location.href = 'https://syntactic-hub.vercel.app',\n      className: \"back-button\",\n      children: \"Back to Syntactic Hub\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 366,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"game-title\",\n      children: \"Grammar Sentence Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 372,\n      columnNumber: 13\n    }, this), !mode ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mode-selection\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Choose your practice mode:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 377,\n        columnNumber: 21\n      }, this), Object.values(MODES).map(modeOption => /*#__PURE__*/_jsxDEV(\"button\", {\n        className: `mode-button ${mode === modeOption ? 'selected' : ''}`,\n        onClick: () => setMode(modeOption),\n        children: modeOption\n      }, modeOption, false, {\n        fileName: _jsxFileName,\n        lineNumber: 379,\n        columnNumber: 25\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 376,\n      columnNumber: 17\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-score\",\n        children: [\"Score: \", score, /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 392,\n          columnNumber: 25\n        }, this), \"Question \", sentences.length - availableSentences.length + 1, \" of \", sentences.length]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 390,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tries-counter\",\n        children: [\"Tries Left: \", triesLeft]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 395,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-container\",\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: currentImage,\n          alt: \"Scene to describe\",\n          className: \"prompt-image\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 401,\n          columnNumber: 25\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 400,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"sentence-slots\",\n        children: sentenceSlots.map(slot => /*#__PURE__*/_jsxDEV(SentenceSlot, {\n          id: slot.id,\n          tile: slot.wordTile,\n          isError: isError,\n          onClick: () => slot.wordTile ? handleSlotReset(slot.id) : handleSlotClick(slot.id)\n        }, slot.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 411,\n          columnNumber: 29\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 409,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"word-tiles\",\n        children: wordTiles.map(tile => /*#__PURE__*/_jsxDEV(WordTile, {\n          id: tile.id,\n          imagePath: tile.imagePath,\n          isUsed: tile.isUsed,\n          isSelected: selectedTile === tile.id,\n          onClick: () => handleTileClick(tile.id)\n        }, tile.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 426,\n          columnNumber: 29\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 424,\n        columnNumber: 21\n      }, this), feedback && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `feedback ${isError ? 'error' : 'success'}`,\n        children: feedback\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 438,\n        columnNumber: 25\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          margin: '20px',\n          padding: '10px',\n          border: '2px solid red',\n          background: '#ffe0e0'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"Debug Info:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 443,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Expected Order: \", JSON.stringify(correctOrderForCurrentSentence)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 444,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Current Picture: \", availableSentences.length > 0 ? availableSentences[0].Picture : 'None']\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 445,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 442,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 365,\n    columnNumber: 9\n  }, this);\n}\n_s(GrammarGame, \"gAubdnSq0A6ylX8oGyQYrdcU9hU=\");\n_c = GrammarGame;\nexport default GrammarGame;\nvar _c;\n$RefreshReg$(_c, \"GrammarGame\");","map":{"version":3,"names":["React","useState","useEffect","Papa","WordTile","SentenceSlot","jsxDEV","_jsxDEV","Fragment","_Fragment","MODES","PASSIVE","IMPERFECT","OBJECT_CLEFT","WH_QUESTION","MAX_TRIES","POINTS_PER_QUESTION","PENALTY_PER_TRY","GrammarGame","_s","mode","setMode","sentences","setSentences","availableSentences","setAvailableSentences","currentImage","setCurrentImage","correctOrderForCurrentSentence","setCorrectOrderForCurrentSentence","score","setScore","triesLeft","setTriesLeft","feedback","setFeedback","isError","setIsError","isComplete","setIsComplete","results","setResults","wordTiles","setWordTiles","sentenceSlots","setSentenceSlots","selectedTile","setSelectedTile","loadSentences","response","fetch","csvText","text","parse","header","skipEmptyLines","complete","data","shuffleArray","error","console","getModeColumn","getCorrectOrder","gameMode","pictureId","prefix","charAt","version2","includes","length","setupNewTrial","sentence","Picture","trim","imagePath","correctOrder","log","modeFolderMap","modeFolder","toLowerCase","shuffledTiles","map","tileId","index","id","isUsed","newSlots","_","position","wordTile","handleTileClick","tileIndex","findIndex","t","handleSlotClick","slotId","slotIndex","s","newTiles","every","slot","checkSentence","handleSlotReset","currentSlots","currentOrderIds","isCorrect","i","trialScore","Math","max","image","triesUsed","timestamp","Date","toISOString","setTimeout","newAvailableSentences","slice","array","newArray","j","floor","random","downloadResults","csv","r","row","join","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","averageTries","reduce","sum","toFixed","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","window","location","Object","values","modeOption","src","alt","tile","isSelected","style","margin","padding","border","background","JSON","stringify","_c","$RefreshReg$"],"sources":["/Users/peterpressman/MyDevelopment/JavaScript/SynTactic-online/syntactile-words/src/components/GrammarGame.js"],"sourcesContent":["// src/components/GrammarGame.js\nimport React, { useState, useEffect } from 'react';\nimport Papa from 'papaparse';\nimport WordTile from './WordTile';\nimport SentenceSlot from './SentenceSlot';\nimport './GrammarGame.css';\n\nconst MODES = {\n    PASSIVE: 'Passive Voice',\n    IMPERFECT: 'Imperfect Tense',\n    OBJECT_CLEFT: 'Object Cleft',\n    WH_QUESTION: 'Wh Questions'\n};\n\nconst MAX_TRIES = 3;\nconst POINTS_PER_QUESTION = 10;\nconst PENALTY_PER_TRY = 3;\n\nfunction GrammarGame() {\n    // Game state\n    const [mode, setMode] = useState(null);\n    const [sentences, setSentences] = useState([]);\n    const [availableSentences, setAvailableSentences] = useState([]);\n    const [currentImage, setCurrentImage] = useState(null);\n    const [correctOrderForCurrentSentence, setCorrectOrderForCurrentSentence] = useState([]);\n    const [score, setScore] = useState(0);\n    const [triesLeft, setTriesLeft] = useState(MAX_TRIES);\n    const [feedback, setFeedback] = useState('');\n    const [isError, setIsError] = useState(false);\n    const [isComplete, setIsComplete] = useState(false);\n    const [results, setResults] = useState([]);\n\n    // Tiles and slots state\n    const [wordTiles, setWordTiles] = useState([]);\n    const [sentenceSlots, setSentenceSlots] = useState([]);\n    const [selectedTile, setSelectedTile] = useState(null);\n\n    // Load sentences from CSV\n    useEffect(() => {\n        loadSentences();\n    }, []);\n\n    const loadSentences = async () => {\n        try {\n            const response = await fetch('/sentences_corrected.csv');\n            const csvText = await response.text();\n            \n            Papa.parse(csvText, {\n                header: true,\n                skipEmptyLines: true,\n                complete: (results) => {\n                    // Store all sentences\n                    setSentences(results.data);\n                    // Also create a randomized copy for selection\n                    setAvailableSentences(shuffleArray([...results.data]));\n                }\n            });\n        } catch (error) {\n            console.error('Error loading CSV:', error);\n        }\n    };\n\n    // Map CSV columns to mode names\n    const getModeColumn = (mode) => {\n        switch(mode) {\n            case MODES.PASSIVE:\n                return \"Passive\";\n            case MODES.IMPERFECT:\n                return \"Progressive Active\";\n            case MODES.OBJECT_CLEFT:\n                return \"Object Cleft\";\n            case MODES.WH_QUESTION:\n                return \"Wh Question\";\n            default:\n                return \"\";\n        }\n    };\n\n    // Get tile order based on mode and picture ID\n    const getCorrectOrder = (gameMode, pictureId) => {\n        const prefix = pictureId.charAt(0);\n        const version2 = pictureId.includes(\"2\");\n        \n        switch(gameMode) {\n            case MODES.IMPERFECT:\n                return version2 ? \n                    [`${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] :\n                    [`${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n            case MODES.PASSIVE:\n                return version2 ?\n                    [`${prefix}1`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}2`] :\n                    [`${prefix}2`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}1`];\n            case MODES.OBJECT_CLEFT:\n                return version2 ?\n                    [`${prefix}4`, `${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] :\n                    [`${prefix}4`, `${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n            case MODES.WH_QUESTION:\n                return version2 ?\n                    [`${prefix}5`, `${prefix}4`, `${prefix}2`, `${prefix}3`, `${prefix}1`, `${prefix}6`] :\n                    [`${prefix}5`, `${prefix}4`, `${prefix}1`, `${prefix}3`, `${prefix}2`, `${prefix}6`];\n            default:\n                return [];\n        }\n    };\n\n    // Setup a new trial when mode or availableSentences changes\n    useEffect(() => {\n        if (mode && availableSentences.length > 0) {\n            setupNewTrial();\n        }\n    }, [mode, availableSentences]);\n\n    const setupNewTrial = () => {\n        if (availableSentences.length === 0) return;\n        \n        // Get a sentence from the randomized array\n        const sentence = availableSentences[0];\n        const pictureId = sentence.Picture.trim();\n        \n        const imagePath = `/images/Pic${pictureId}.jpg`;\n        setCurrentImage(imagePath);\n        \n        // Get the correct tile order for this sentence\n        const correctOrder = getCorrectOrder(mode, pictureId);\n        console.log('Setting up trial for:', pictureId);\n        console.log('Expected order:', correctOrder);\n        setCorrectOrderForCurrentSentence(correctOrder);   \n\n        // Map folders to modes\n        const modeFolderMap = {\n            \"Passive Voice\": \"passive\",\n            \"Imperfect Tense\": \"imperfect\",\n            \"Object Cleft\": \"object_cleft\",\n            \"Wh Questions\": \"wh_questions\"\n        };\n        \n        const modeFolder = modeFolderMap[mode] || mode.toLowerCase();\n        \n        // Create tiles with the correct prefix\n        const shuffledTiles = shuffleArray(\n            correctOrder.map((tileId, index) => ({\n                id: `tile-${index}`,\n                tileId: tileId,\n                imagePath: `/tiles/${modeFolder}/${tileId}.png`,\n                isUsed: false\n            }))\n        );\n        \n        setWordTiles(shuffledTiles);\n        \n        // Create empty sentence slots\n        const newSlots = correctOrder.map((_, index) => ({\n            id: `slot-${index}`,\n            position: index,\n            tileId: null,\n            wordTile: null\n        }));\n        \n        setSentenceSlots(newSlots);\n        setTriesLeft(MAX_TRIES);\n        setFeedback('');\n        setIsError(false);\n        setSelectedTile(null);\n    };\n\n    // Handle tile selection\n    const handleTileClick = (tileId) => {\n        const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n        if (tileIndex !== -1 && !wordTiles[tileIndex].isUsed) {\n            setSelectedTile(tileId);\n        }\n    };\n\n    // Handle slot click - place a selected tile in a slot\n    const handleSlotClick = (slotId) => {\n        if (!selectedTile) return;\n        \n        const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n        \n        // Only allow placement in empty slots\n        if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId === null) {\n            // Find the tile\n            const tileIndex = wordTiles.findIndex(t => t.id === selectedTile);\n            \n            // Update slots with the placed tile\n            const newSlots = [...sentenceSlots];\n            newSlots[slotIndex] = {\n                ...newSlots[slotIndex],\n                tileId: selectedTile,\n                wordTile: wordTiles[tileIndex]\n            };\n            setSentenceSlots(newSlots);\n            \n            // Mark the tile as used\n            const newTiles = [...wordTiles];\n            newTiles[tileIndex] = {\n                ...newTiles[tileIndex],\n                isUsed: true\n            };\n            setWordTiles(newTiles);\n            \n            // Clear selection\n            setSelectedTile(null);\n            \n            // Check if sentence is complete\n            if (newSlots.every(slot => slot.wordTile !== null)) {\n                checkSentence(newSlots);\n            }\n        }\n    };\n\n    // Remove a tile from a slot\n    const handleSlotReset = (slotId) => {\n        const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n        if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId) {\n            const tileId = sentenceSlots[slotIndex].tileId;\n            \n            // Clear the slot\n            const newSlots = [...sentenceSlots];\n            newSlots[slotIndex] = {\n                ...newSlots[slotIndex],\n                tileId: null,\n                wordTile: null\n            };\n            setSentenceSlots(newSlots);\n            \n            // Mark the tile as available again\n            const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n            const newTiles = [...wordTiles];\n            newTiles[tileIndex] = {\n                ...newTiles[tileIndex],\n                isUsed: false\n            };\n            setWordTiles(newTiles);\n        }\n    };\n\n    // Check if the sentence is correct\n    const checkSentence = (currentSlots) => {\n        // Compare the current order with the correct order that was \n        // stored during setupNewTrial\n        \n        // Extract tileIds from the slots\n        const currentOrderIds = currentSlots.map(slot => slot.wordTile ? slot.wordTile.tileId : null);\n        console.log('User arrangement:', currentOrderIds);\n        console.log('Expected arrangement:', correctOrderForCurrentSentence);\n        \n        // Compare with the correct order for this sentence\n        let isCorrect = true;\n        for (let i = 0; i < correctOrderForCurrentSentence.length; i++) {\n            if (currentOrderIds[i] !== correctOrderForCurrentSentence[i]) {\n                isCorrect = false;\n                break;\n            }\n        }\n\n        if (isCorrect) {\n            const trialScore = Math.max(\n                POINTS_PER_QUESTION - ((MAX_TRIES - triesLeft) * PENALTY_PER_TRY), \n                0\n            );\n            setScore(score + trialScore);\n            setFeedback('Correct! Moving to next image...');\n            \n            setResults([...results, {\n                image: currentImage,\n                mode,\n                triesUsed: MAX_TRIES - triesLeft,\n                score: trialScore,\n                timestamp: new Date().toISOString()\n            }]);\n\n            setTimeout(() => {\n                if (availableSentences.length > 1) {\n                    // Remove the current sentence from available pool\n                    const newAvailableSentences = [...availableSentences.slice(1)];\n                    setAvailableSentences(newAvailableSentences);\n                    setFeedback('');\n                } else {\n                    setIsComplete(true);\n                }\n            }, 1500);\n        } else {\n            setIsError(true);\n            setTriesLeft(triesLeft - 1);\n            \n            if (triesLeft <= 1) {\n                setFeedback('Out of tries. Moving to next question...');\n                setTimeout(() => {\n                    if (availableSentences.length > 1) {\n                        // Remove the current sentence from available pool\n                        const newAvailableSentences = [...availableSentences.slice(1)];\n                        setAvailableSentences(newAvailableSentences);\n                        setFeedback('');\n                    } else {\n                        setIsComplete(true);\n                    }\n                }, 1500);\n            } else {\n                setFeedback(`Incorrect! ${triesLeft - 1} tries left`);\n                setTimeout(() => setIsError(false), 1000);\n            }\n        }\n    };\n\n    // Helper function to shuffle array\n    const shuffleArray = (array) => {\n        const newArray = [...array];\n        for (let i = newArray.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n        }\n        return newArray;\n    };\n\n    // Function to download results as CSV\n    const downloadResults = () => {\n        const csv = [\n            ['Image', 'Mode', 'Tries Used', 'Score', 'Timestamp'],\n            ...results.map(r => [\n                r.image, r.mode, r.triesUsed, r.score, r.timestamp\n            ])\n        ].map(row => row.join(',')).join('\\n');\n\n        const blob = new Blob([csv], { type: 'text/csv' });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = 'grammar_game_results.csv';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    };\n\n    // Game complete screen\n    if (isComplete) {\n        const averageTries = (results.reduce((sum, r) => sum + r.triesUsed, 0) / results.length).toFixed(1);\n        return (\n            <div className=\"game-container\">\n                <h1 className=\"game-title\">Game Complete</h1>\n                <p className=\"game-score\">\n                    Final Score: {score}\n                    <br />\n                    Average tries per question: {averageTries}\n                </p>\n                <button \n                    className=\"mode-button\"\n                    onClick={downloadResults}\n                >\n                    Download Results\n                </button>\n                <div className=\"back-to-hub\">\n                    <button \n                        className=\"back-button\"\n                        onClick={() => window.location.href = 'https://syntactic-hub.vercel.app'}\n                    >\n                        Back to Syntactic Hub\n                    </button>\n                </div>\n            </div>\n        );\n    }\n\n    return (\n        <div className=\"game-container\">\n            <button \n                onClick={() => window.location.href = 'https://syntactic-hub.vercel.app'}\n                className=\"back-button\"\n            >\n                Back to Syntactic Hub\n            </button>\n            <h1 className=\"game-title\">Grammar Sentence Game</h1>\n            \n            {/* Mode selection */}\n            {!mode ? (\n                <div className=\"mode-selection\">\n                    <h2>Choose your practice mode:</h2>\n                    {Object.values(MODES).map((modeOption) => (\n                        <button\n                            key={modeOption}\n                            className={`mode-button ${mode === modeOption ? 'selected' : ''}`}\n                            onClick={() => setMode(modeOption)}\n                        >\n                            {modeOption}\n                        </button>\n                    ))}\n                </div>\n            ) : (\n                <>\n                    <div className=\"game-score\">\n                        Score: {score}\n                        <br />\n                        Question {sentences.length - availableSentences.length + 1} of {sentences.length}\n                    </div>\n                    <div className=\"tries-counter\">\n                        Tries Left: {triesLeft}\n                    </div>\n                    \n                    {/* Image prompt */}\n                    <div className=\"image-container\">\n                        <img\n                            src={currentImage}\n                            alt=\"Scene to describe\"\n                            className=\"prompt-image\"\n                        />\n                    </div>\n                    \n                    {/* Sentence slots */}\n                    <div className=\"sentence-slots\">\n                        {sentenceSlots.map(slot => (\n                            <SentenceSlot\n                                key={slot.id}\n                                id={slot.id}\n                                tile={slot.wordTile}\n                                isError={isError}\n                                onClick={() => slot.wordTile \n                                    ? handleSlotReset(slot.id) \n                                    : handleSlotClick(slot.id)}\n                            />\n                        ))}\n                    </div>\n                    \n                    {/* Word tiles */}\n                    <div className=\"word-tiles\">\n                        {wordTiles.map(tile => (\n                            <WordTile\n                                key={tile.id}\n                                id={tile.id}\n                                imagePath={tile.imagePath}\n                                isUsed={tile.isUsed}\n                                isSelected={selectedTile === tile.id}\n                                onClick={() => handleTileClick(tile.id)}\n                            />\n                        ))}\n                    </div>\n                    \n                    {feedback && (\n                        <div className={`feedback ${isError ? 'error' : 'success'}`}>\n                            {feedback}\n                        </div>\n                    )}\n                    <div style={{margin: '20px', padding: '10px', border: '2px solid red', background: '#ffe0e0'}}>\n                        <h3>Debug Info:</h3>\n                        <p>Expected Order: {JSON.stringify(correctOrderForCurrentSentence)}</p>\n                        <p>Current Picture: {availableSentences.length > 0 ? availableSentences[0].Picture : 'None'}</p>\n                    </div>\n                </>\n            )}\n        </div>\n    );\n}\n\nexport default GrammarGame;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}