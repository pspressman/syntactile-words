{"ast":null,"code":"var _jsxFileName = \"/Users/peterpressman/MyDevelopment/JavaScript/SynTactic-online/syntactile-words/src/components/GrammarGame.js\",\n  _s = $RefreshSig$();\n// src/GrammarGame.js\nimport React, { useState, useEffect } from 'react';\nimport Papa from 'papaparse';\nimport WordTile from './WordTile';\nimport SentenceSlot from './SentenceSlot';\nimport './GrammarGame.css';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODES = {\n  PASSIVE: 'Passive Voice',\n  IMPERFECT: 'Imperfect Tense',\n  OBJECT_CLEFT: 'Object Cleft',\n  WH_QUESTION: 'Wh Questions'\n};\nconst MAX_TRIES = 3;\nconst POINTS_PER_QUESTION = 10;\nconst PENALTY_PER_TRY = 3;\nfunction GrammarGame() {\n  _s();\n  // Game state\n  const [mode, setMode] = useState(null);\n  const [sentences, setSentences] = useState([]);\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [currentImage, setCurrentImage] = useState(null);\n  const [isVersion2, setIsVersion2] = useState(false);\n  const [score, setScore] = useState(0);\n  const [triesLeft, setTriesLeft] = useState(MAX_TRIES);\n  const [feedback, setFeedback] = useState('');\n  const [isError, setIsError] = useState(false);\n  const [isComplete, setIsComplete] = useState(false);\n  const [results, setResults] = useState([]);\n\n  // Tiles and slots state\n  const [wordTiles, setWordTiles] = useState([]);\n  const [sentenceSlots, setSentenceSlots] = useState([]);\n  const [selectedTile, setSelectedTile] = useState(null);\n\n  // Load sentences from CSV\n  useEffect(() => {\n    loadSentences();\n  }, []);\n  const loadSentences = async () => {\n    try {\n      const response = await fetch('/sentences_corrected.csv');\n      const csvText = await response.text();\n      Papa.parse(csvText, {\n        header: true,\n        skipEmptyLines: true,\n        complete: results => {\n          setSentences(results.data);\n        }\n      });\n    } catch (error) {\n      console.error('Error loading CSV:', error);\n    }\n  };\n\n  // Modified getCorrectOrder function\n  const getCorrectOrder = (gameMode, version2, pictureId) => {\n    // Extract prefix (A, B, etc.) from the pictureId\n    const prefix = pictureId.charAt(0);\n    switch (gameMode) {\n      case MODES.IMPERFECT:\n        return version2 ? [`${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] : [`${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n      case MODES.PASSIVE:\n        return version2 ? [`${prefix}1`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}2`, `${prefix}3`] : [`${prefix}2`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}1`, `${prefix}3`];\n      case MODES.OBJECT_CLEFT:\n        return version2 ? [`${prefix}4`, `${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] : [`${prefix}4`, `${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n      case MODES.WH_QUESTION:\n        return version2 ? [`${prefix}5`, `${prefix}4`, `${prefix}2`, `${prefix}3`, `${prefix}1`, `${prefix}6`] : [`${prefix}5`, `${prefix}4`, `${prefix}1`, `${prefix}3`, `${prefix}2`, `${prefix}6`];\n      default:\n        return [];\n    }\n  };\n\n  // Setup a new trial when mode or currentTrial changes\n  useEffect(() => {\n    if (mode && sentences.length > 0) {\n      setupNewTrial();\n    }\n  }, [mode, currentTrial, sentences]);\n  const setupNewTrial = () => {\n    if (!sentences[currentTrial]) return;\n    const sentence = sentences[currentTrial];\n    const version2 = sentence.Picture.includes(\"2\");\n    setIsVersion2(version2);\n    const pictureId = sentence.Picture.trim();\n    const imagePath = `/images/Pic${pictureId}.jpg`;\n    setCurrentImage(imagePath);\n    const tileOrder = getCorrectOrder(mode, version2, pictureId);\n\n    // Define mode-to-folder mapping\n    const modeFolderMap = {\n      \"Passive Voice\": \"passive\",\n      \"Imperfect Tense\": \"imperfect\",\n      \"Object Cleft\": \"object_cleft\",\n      \"Wh Questions\": \"wh_questions\"\n    };\n\n    // Ensure mode maps to the correct folder name\n    const modeFolder = modeFolderMap[mode] || mode.toLowerCase();\n\n    // Create shuffled tiles\n    const shuffledTiles = shuffleArray(tileOrder.map((tileId, index) => ({\n      id: `tile-${index}`,\n      tileId: tileId,\n      imagePath: `/tiles/${modeFolder}/${tileId}.png`,\n      isUsed: false\n    })));\n    setWordTiles(shuffledTiles);\n\n    // Create empty sentence slots\n    const newSlots = tileOrder.map((_, index) => ({\n      id: `slot-${index}`,\n      position: index,\n      tileId: null,\n      wordTile: null\n    }));\n    setSentenceSlots(newSlots);\n    setTriesLeft(MAX_TRIES);\n    setFeedback('');\n    setIsError(false);\n    setSelectedTile(null);\n  };\n\n  // Handle tile selection\n  const handleTileClick = tileId => {\n    const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n    if (tileIndex !== -1 && !wordTiles[tileIndex].isUsed) {\n      setSelectedTile(tileId);\n    }\n  };\n\n  // Handle slot click - place a selected tile in a slot\n  const handleSlotClick = slotId => {\n    if (!selectedTile) return;\n    const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n\n    // Only allow placement in empty slots\n    if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId === null) {\n      // Find the tile\n      const tileIndex = wordTiles.findIndex(t => t.id === selectedTile);\n\n      // Update slots with the placed tile\n      const newSlots = [...sentenceSlots];\n      newSlots[slotIndex] = {\n        ...newSlots[slotIndex],\n        tileId: selectedTile,\n        wordTile: wordTiles[tileIndex]\n      };\n      setSentenceSlots(newSlots);\n\n      // Mark the tile as used\n      const newTiles = [...wordTiles];\n      newTiles[tileIndex] = {\n        ...newTiles[tileIndex],\n        isUsed: true\n      };\n      setWordTiles(newTiles);\n\n      // Clear selection\n      setSelectedTile(null);\n\n      // Check if sentence is complete\n      if (newSlots.every(slot => slot.wordTile !== null)) {\n        checkSentence(newSlots);\n      }\n    }\n  };\n\n  // Remove a tile from a slot\n  const handleSlotReset = slotId => {\n    const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n    if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId) {\n      const tileId = sentenceSlots[slotIndex].tileId;\n\n      // Clear the slot\n      const newSlots = [...sentenceSlots];\n      newSlots[slotIndex] = {\n        ...newSlots[slotIndex],\n        tileId: null,\n        wordTile: null\n      };\n      setSentenceSlots(newSlots);\n\n      // Mark the tile as available again\n      const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n      const newTiles = [...wordTiles];\n      newTiles[tileIndex] = {\n        ...newTiles[tileIndex],\n        isUsed: false\n      };\n      setWordTiles(newTiles);\n    }\n  };\n\n  // Check if the sentence is correct\n  const checkSentence = currentSlots => {\n    const correctOrder = getCorrectOrder(mode, isVersion2);\n\n    // Extract tileIds from the slots\n    const currentOrderIds = currentSlots.map(slot => slot.wordTile ? slot.wordTile.tileId : null);\n    const isCorrect = correctOrder.every((tileId, index) => currentOrderIds[index] === tileId);\n    if (isCorrect) {\n      const trialScore = Math.max(POINTS_PER_QUESTION - (MAX_TRIES - triesLeft) * PENALTY_PER_TRY, 0);\n      setScore(score + trialScore);\n      setFeedback('Correct! Moving to next image...');\n      setResults([...results, {\n        image: currentImage,\n        mode,\n        triesUsed: MAX_TRIES - triesLeft,\n        score: trialScore,\n        timestamp: new Date().toISOString()\n      }]);\n      setTimeout(() => {\n        if (currentTrial < sentences.length - 1) {\n          setCurrentTrial(currentTrial + 1);\n          setFeedback('');\n        } else {\n          setIsComplete(true);\n        }\n      }, 1500);\n    } else {\n      setIsError(true);\n      setTriesLeft(triesLeft - 1);\n      if (triesLeft <= 1) {\n        setFeedback('Out of tries. Moving to next question...');\n        setTimeout(() => {\n          if (currentTrial < sentences.length - 1) {\n            setCurrentTrial(currentTrial + 1);\n            setFeedback('');\n          } else {\n            setIsComplete(true);\n          }\n        }, 1500);\n      } else {\n        setFeedback(`Incorrect! ${triesLeft - 1} tries left`);\n        setTimeout(() => setIsError(false), 1000);\n      }\n    }\n  };\n\n  // Helper function to shuffle array\n  const shuffleArray = array => {\n    const newArray = [...array];\n    for (let i = newArray.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n    }\n    return newArray;\n  };\n\n  // Function to download results as CSV\n  const downloadResults = () => {\n    const csv = [['Image', 'Mode', 'Tries Used', 'Score', 'Timestamp'], ...results.map(r => [r.image, r.mode, r.triesUsed, r.score, r.timestamp])].map(row => row.join(',')).join('\\n');\n    const blob = new Blob([csv], {\n      type: 'text/csv'\n    });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = 'grammar_game_results.csv';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  };\n\n  // Game complete screen\n  if (isComplete) {\n    const averageTries = (results.reduce((sum, r) => sum + r.triesUsed, 0) / results.length).toFixed(1);\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        className: \"game-title\",\n        children: \"Game Complete\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 309,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"game-score\",\n        children: [\"Final Score: \", score, /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 312,\n          columnNumber: 21\n        }, this), \"Average tries per question: \", averageTries]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 310,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"mode-button\",\n        onClick: downloadResults,\n        children: \"Download Results\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 315,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 308,\n      columnNumber: 13\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => window.location.href = '/',\n      className: \"back-button\",\n      children: \"Back\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 327,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"game-title\",\n      children: \"Grammar Sentence Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 333,\n      columnNumber: 13\n    }, this), !mode ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mode-selection\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Choose your practice mode:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 21\n      }, this), Object.values(MODES).map(modeOption => /*#__PURE__*/_jsxDEV(\"button\", {\n        className: `mode-button ${mode === modeOption ? 'selected' : ''}`,\n        onClick: () => setMode(modeOption),\n        children: modeOption\n      }, modeOption, false, {\n        fileName: _jsxFileName,\n        lineNumber: 340,\n        columnNumber: 25\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 337,\n      columnNumber: 17\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-score\",\n        children: [\"Score: \", score, /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 353,\n          columnNumber: 25\n        }, this), \"Question \", currentTrial + 1, \" of \", sentences.length]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 351,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tries-counter\",\n        children: [\"Tries Left: \", triesLeft]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 356,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-container\",\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: currentImage,\n          alt: \"Scene to describe\",\n          className: \"prompt-image\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 362,\n          columnNumber: 25\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 361,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"sentence-slots\",\n        children: sentenceSlots.map(slot => /*#__PURE__*/_jsxDEV(SentenceSlot, {\n          id: slot.id,\n          tile: slot.wordTile,\n          isError: isError,\n          onClick: () => slot.wordTile ? handleSlotReset(slot.id) : handleSlotClick(slot.id)\n        }, slot.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 372,\n          columnNumber: 29\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 370,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"word-tiles\",\n        children: wordTiles.map(tile => /*#__PURE__*/_jsxDEV(WordTile, {\n          id: tile.id,\n          imagePath: tile.imagePath,\n          isUsed: tile.isUsed,\n          isSelected: selectedTile === tile.id,\n          onClick: () => handleTileClick(tile.id)\n        }, tile.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 387,\n          columnNumber: 29\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 385,\n        columnNumber: 21\n      }, this), feedback && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `feedback ${isError ? 'error' : 'success'}`,\n        children: feedback\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 399,\n        columnNumber: 25\n      }, this)]\n    }, void 0, true)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 326,\n    columnNumber: 9\n  }, this);\n}\n_s(GrammarGame, \"3iEl0IBhuAwGANsJTy54o3D6hWU=\");\n_c = GrammarGame;\nexport default GrammarGame;\nvar _c;\n$RefreshReg$(_c, \"GrammarGame\");","map":{"version":3,"names":["React","useState","useEffect","Papa","WordTile","SentenceSlot","jsxDEV","_jsxDEV","Fragment","_Fragment","MODES","PASSIVE","IMPERFECT","OBJECT_CLEFT","WH_QUESTION","MAX_TRIES","POINTS_PER_QUESTION","PENALTY_PER_TRY","GrammarGame","_s","mode","setMode","sentences","setSentences","currentTrial","setCurrentTrial","currentImage","setCurrentImage","isVersion2","setIsVersion2","score","setScore","triesLeft","setTriesLeft","feedback","setFeedback","isError","setIsError","isComplete","setIsComplete","results","setResults","wordTiles","setWordTiles","sentenceSlots","setSentenceSlots","selectedTile","setSelectedTile","loadSentences","response","fetch","csvText","text","parse","header","skipEmptyLines","complete","data","error","console","getCorrectOrder","gameMode","version2","pictureId","prefix","charAt","length","setupNewTrial","sentence","Picture","includes","trim","imagePath","tileOrder","modeFolderMap","modeFolder","toLowerCase","shuffledTiles","shuffleArray","map","tileId","index","id","isUsed","newSlots","_","position","wordTile","handleTileClick","tileIndex","findIndex","t","handleSlotClick","slotId","slotIndex","s","newTiles","every","slot","checkSentence","handleSlotReset","currentSlots","correctOrder","currentOrderIds","isCorrect","trialScore","Math","max","image","triesUsed","timestamp","Date","toISOString","setTimeout","array","newArray","i","j","floor","random","downloadResults","csv","r","row","join","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","averageTries","reduce","sum","toFixed","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","window","location","Object","values","modeOption","src","alt","tile","isSelected","_c","$RefreshReg$"],"sources":["/Users/peterpressman/MyDevelopment/JavaScript/SynTactic-online/syntactile-words/src/components/GrammarGame.js"],"sourcesContent":["// src/GrammarGame.js\nimport React, { useState, useEffect } from 'react';\nimport Papa from 'papaparse';\nimport WordTile from './WordTile';\nimport SentenceSlot from './SentenceSlot';\nimport './GrammarGame.css';\n\nconst MODES = {\n    PASSIVE: 'Passive Voice',\n    IMPERFECT: 'Imperfect Tense',\n    OBJECT_CLEFT: 'Object Cleft',\n    WH_QUESTION: 'Wh Questions'\n};\n\nconst MAX_TRIES = 3;\nconst POINTS_PER_QUESTION = 10;\nconst PENALTY_PER_TRY = 3;\n\nfunction GrammarGame() {\n    // Game state\n    const [mode, setMode] = useState(null);\n    const [sentences, setSentences] = useState([]);\n    const [currentTrial, setCurrentTrial] = useState(0);\n    const [currentImage, setCurrentImage] = useState(null);\n    const [isVersion2, setIsVersion2] = useState(false);\n    const [score, setScore] = useState(0);\n    const [triesLeft, setTriesLeft] = useState(MAX_TRIES);\n    const [feedback, setFeedback] = useState('');\n    const [isError, setIsError] = useState(false);\n    const [isComplete, setIsComplete] = useState(false);\n    const [results, setResults] = useState([]);\n\n    // Tiles and slots state\n    const [wordTiles, setWordTiles] = useState([]);\n    const [sentenceSlots, setSentenceSlots] = useState([]);\n    const [selectedTile, setSelectedTile] = useState(null);\n\n    // Load sentences from CSV\n    useEffect(() => {\n        loadSentences();\n    }, []);\n\n    const loadSentences = async () => {\n        try {\n            const response = await fetch('/sentences_corrected.csv');\n            const csvText = await response.text();\n            \n            Papa.parse(csvText, {\n                header: true,\n                skipEmptyLines: true,\n                complete: (results) => {\n                    setSentences(results.data);\n                }\n            });\n        } catch (error) {\n            console.error('Error loading CSV:', error);\n        }\n    };\n\n    // Modified getCorrectOrder function\n    const getCorrectOrder = (gameMode, version2, pictureId) => {\n        // Extract prefix (A, B, etc.) from the pictureId\n        const prefix = pictureId.charAt(0);\n        \n        switch(gameMode) {\n            case MODES.IMPERFECT:\n                return version2 ? \n                    [`${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] :\n                    [`${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n            case MODES.PASSIVE:\n                return version2 ?\n                    [`${prefix}1`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}2`, `${prefix}3`] :\n                    [`${prefix}2`, `${prefix}5`, `${prefix}4`, `${prefix}6`, `${prefix}1`, `${prefix}3`];\n            case MODES.OBJECT_CLEFT:\n                return version2 ?\n                    [`${prefix}4`, `${prefix}2`, `${prefix}5`, `${prefix}3`, `${prefix}1`] :\n                    [`${prefix}4`, `${prefix}1`, `${prefix}5`, `${prefix}3`, `${prefix}2`];\n            case MODES.WH_QUESTION:\n                return version2 ?\n                    [`${prefix}5`, `${prefix}4`, `${prefix}2`, `${prefix}3`, `${prefix}1`, `${prefix}6`] :\n                    [`${prefix}5`, `${prefix}4`, `${prefix}1`, `${prefix}3`, `${prefix}2`, `${prefix}6`];\n            default:\n                return [];\n        }\n    };\n\n    // Setup a new trial when mode or currentTrial changes\n    useEffect(() => {\n        if (mode && sentences.length > 0) {\n            setupNewTrial();\n        }\n    }, [mode, currentTrial, sentences]);\n\n    const setupNewTrial = () => {\n        if (!sentences[currentTrial]) return;\n        \n        const sentence = sentences[currentTrial];\n        const version2 = sentence.Picture.includes(\"2\");\n        setIsVersion2(version2);\n        \n        const pictureId = sentence.Picture.trim();\n        const imagePath = `/images/Pic${pictureId}.jpg`;\n        setCurrentImage(imagePath);\n        \n        const tileOrder = getCorrectOrder(mode, version2, pictureId);\n        \n        // Define mode-to-folder mapping\n        const modeFolderMap = {\n            \"Passive Voice\": \"passive\",\n            \"Imperfect Tense\": \"imperfect\",\n            \"Object Cleft\": \"object_cleft\",\n            \"Wh Questions\": \"wh_questions\"\n        };\n        \n        // Ensure mode maps to the correct folder name\n        const modeFolder = modeFolderMap[mode] || mode.toLowerCase();\n        \n        // Create shuffled tiles\n        const shuffledTiles = shuffleArray(\n            tileOrder.map((tileId, index) => ({\n                id: `tile-${index}`,\n                tileId: tileId,\n                imagePath: `/tiles/${modeFolder}/${tileId}.png`,\n                isUsed: false\n            }))\n        );\n        \n        setWordTiles(shuffledTiles);\n        \n        // Create empty sentence slots\n        const newSlots = tileOrder.map((_, index) => ({\n            id: `slot-${index}`,\n            position: index,\n            tileId: null,\n            wordTile: null\n        }));\n        \n        setSentenceSlots(newSlots);\n        setTriesLeft(MAX_TRIES);\n        setFeedback('');\n        setIsError(false);\n        setSelectedTile(null);\n    };\n\n    // Handle tile selection\n    const handleTileClick = (tileId) => {\n        const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n        if (tileIndex !== -1 && !wordTiles[tileIndex].isUsed) {\n            setSelectedTile(tileId);\n        }\n    };\n\n    // Handle slot click - place a selected tile in a slot\n    const handleSlotClick = (slotId) => {\n        if (!selectedTile) return;\n        \n        const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n        \n        // Only allow placement in empty slots\n        if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId === null) {\n            // Find the tile\n            const tileIndex = wordTiles.findIndex(t => t.id === selectedTile);\n            \n            // Update slots with the placed tile\n            const newSlots = [...sentenceSlots];\n            newSlots[slotIndex] = {\n                ...newSlots[slotIndex],\n                tileId: selectedTile,\n                wordTile: wordTiles[tileIndex]\n            };\n            setSentenceSlots(newSlots);\n            \n            // Mark the tile as used\n            const newTiles = [...wordTiles];\n            newTiles[tileIndex] = {\n                ...newTiles[tileIndex],\n                isUsed: true\n            };\n            setWordTiles(newTiles);\n            \n            // Clear selection\n            setSelectedTile(null);\n            \n            // Check if sentence is complete\n            if (newSlots.every(slot => slot.wordTile !== null)) {\n                checkSentence(newSlots);\n            }\n        }\n    };\n\n    // Remove a tile from a slot\n    const handleSlotReset = (slotId) => {\n        const slotIndex = sentenceSlots.findIndex(s => s.id === slotId);\n        if (slotIndex !== -1 && sentenceSlots[slotIndex].tileId) {\n            const tileId = sentenceSlots[slotIndex].tileId;\n            \n            // Clear the slot\n            const newSlots = [...sentenceSlots];\n            newSlots[slotIndex] = {\n                ...newSlots[slotIndex],\n                tileId: null,\n                wordTile: null\n            };\n            setSentenceSlots(newSlots);\n            \n            // Mark the tile as available again\n            const tileIndex = wordTiles.findIndex(t => t.id === tileId);\n            const newTiles = [...wordTiles];\n            newTiles[tileIndex] = {\n                ...newTiles[tileIndex],\n                isUsed: false\n            };\n            setWordTiles(newTiles);\n        }\n    };\n\n    // Check if the sentence is correct\n    const checkSentence = (currentSlots) => {\n        const correctOrder = getCorrectOrder(mode, isVersion2);\n        \n        // Extract tileIds from the slots\n        const currentOrderIds = currentSlots.map(slot => \n            slot.wordTile ? slot.wordTile.tileId : null\n        );\n        \n        const isCorrect = correctOrder.every((tileId, index) => \n            currentOrderIds[index] === tileId\n        );\n\n        if (isCorrect) {\n            const trialScore = Math.max(\n                POINTS_PER_QUESTION - ((MAX_TRIES - triesLeft) * PENALTY_PER_TRY), \n                0\n            );\n            setScore(score + trialScore);\n            setFeedback('Correct! Moving to next image...');\n            \n            setResults([...results, {\n                image: currentImage,\n                mode,\n                triesUsed: MAX_TRIES - triesLeft,\n                score: trialScore,\n                timestamp: new Date().toISOString()\n            }]);\n\n            setTimeout(() => {\n                if (currentTrial < sentences.length - 1) {\n                    setCurrentTrial(currentTrial + 1);\n                    setFeedback('');\n                } else {\n                    setIsComplete(true);\n                }\n            }, 1500);\n        } else {\n            setIsError(true);\n            setTriesLeft(triesLeft - 1);\n            \n            if (triesLeft <= 1) {\n                setFeedback('Out of tries. Moving to next question...');\n                setTimeout(() => {\n                    if (currentTrial < sentences.length - 1) {\n                        setCurrentTrial(currentTrial + 1);\n                        setFeedback('');\n                    } else {\n                        setIsComplete(true);\n                    }\n                }, 1500);\n            } else {\n                setFeedback(`Incorrect! ${triesLeft - 1} tries left`);\n                setTimeout(() => setIsError(false), 1000);\n            }\n        }\n    };\n\n    // Helper function to shuffle array\n    const shuffleArray = (array) => {\n        const newArray = [...array];\n        for (let i = newArray.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n        }\n        return newArray;\n    };\n\n    // Function to download results as CSV\n    const downloadResults = () => {\n        const csv = [\n            ['Image', 'Mode', 'Tries Used', 'Score', 'Timestamp'],\n            ...results.map(r => [\n                r.image, r.mode, r.triesUsed, r.score, r.timestamp\n            ])\n        ].map(row => row.join(',')).join('\\n');\n\n        const blob = new Blob([csv], { type: 'text/csv' });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = 'grammar_game_results.csv';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    };\n\n    // Game complete screen\n    if (isComplete) {\n        const averageTries = (results.reduce((sum, r) => sum + r.triesUsed, 0) / results.length).toFixed(1);\n        return (\n            <div className=\"game-container\">\n                <h1 className=\"game-title\">Game Complete</h1>\n                <p className=\"game-score\">\n                    Final Score: {score}\n                    <br />\n                    Average tries per question: {averageTries}\n                </p>\n                <button \n                    className=\"mode-button\"\n                    onClick={downloadResults}\n                >\n                    Download Results\n                </button>\n            </div>\n        );\n    }\n\n    return (\n        <div className=\"game-container\">\n            <button \n                onClick={() => window.location.href = '/'}\n                className=\"back-button\"\n            >\n                Back\n            </button>\n            <h1 className=\"game-title\">Grammar Sentence Game</h1>\n            \n            {/* Mode selection */}\n            {!mode ? (\n                <div className=\"mode-selection\">\n                    <h2>Choose your practice mode:</h2>\n                    {Object.values(MODES).map((modeOption) => (\n                        <button\n                            key={modeOption}\n                            className={`mode-button ${mode === modeOption ? 'selected' : ''}`}\n                            onClick={() => setMode(modeOption)}\n                        >\n                            {modeOption}\n                        </button>\n                    ))}\n                </div>\n            ) : (\n                <>\n                    <div className=\"game-score\">\n                        Score: {score}\n                        <br />\n                        Question {currentTrial + 1} of {sentences.length}\n                    </div>\n                    <div className=\"tries-counter\">\n                        Tries Left: {triesLeft}\n                    </div>\n                    \n                    {/* Image prompt */}\n                    <div className=\"image-container\">\n                        <img\n                            src={currentImage}\n                            alt=\"Scene to describe\"\n                            className=\"prompt-image\"\n                        />\n                    </div>\n                    \n                    {/* Sentence slots */}\n                    <div className=\"sentence-slots\">\n                        {sentenceSlots.map(slot => (\n                            <SentenceSlot\n                                key={slot.id}\n                                id={slot.id}\n                                tile={slot.wordTile}\n                                isError={isError}\n                                onClick={() => slot.wordTile \n                                    ? handleSlotReset(slot.id) \n                                    : handleSlotClick(slot.id)}\n                            />\n                        ))}\n                    </div>\n                    \n                    {/* Word tiles */}\n                    <div className=\"word-tiles\">\n                        {wordTiles.map(tile => (\n                            <WordTile\n                                key={tile.id}\n                                id={tile.id}\n                                imagePath={tile.imagePath}\n                                isUsed={tile.isUsed}\n                                isSelected={selectedTile === tile.id}\n                                onClick={() => handleTileClick(tile.id)}\n                            />\n                        ))}\n                    </div>\n                    \n                    {feedback && (\n                        <div className={`feedback ${isError ? 'error' : 'success'}`}>\n                            {feedback}\n                        </div>\n                    )}\n                </>\n            )}\n        </div>\n    );\n}\n\nexport default GrammarGame;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}